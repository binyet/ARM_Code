L 1 "Source\lcdlib.c"
N/*********************************************************************************************
N* File name:	lcdlib.c
N* Author:		Embest
N* Descript:		LCD_Test 
N* History:
N*********************************************************************************************/
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								include files						 				    */
N/*------------------------------------------------------------------------------------------*/
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030024
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 12 "Source\lcdlib.c" 2
N#include "2410lib.h"
L 1 "..\Common\Inc\2410lib.h" 1
N/*********************************************************************************************
N* File name	: 2410lib.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*********************************************************************************************/
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								include files						 				    */
N/*------------------------------------------------------------------------------------------*/
N#include "def.h"
L 1 "..\Common\Inc\def.h" 1
N/*********************************************************************************************
N* File name	: 2410lib.h
N* Author	: embest
N* Descript	: S3C2410 Example 
N* History
N*********************************************************************************************/
N#ifndef __DEF_H__
N#define __DEF_H__
N
N#define UINT32T unsigned int
N#define INT32T	int
N#define UINT16T unsigned short
N#define INT16T	short int
N#define UINT8T  unsigned char
N#define	INT8T  char
N
N#define TRUE 	1
N#define FALSE 	0
N#define OK		1
N#define FAIL	0
N#define FileEnd	1
N#define	NotEnd	0
N
N#define False 0
N#define True !False
N
N// Sets the result on bPort 
N#define BIT_SET(bPort,bBitMask)        (bPort |= bBitMask)
N#define BIT_CLR(bPort,bBitMask)        (bPort &= ~bBitMask)
N
N// Returns the result
N#define GET_BIT_SET(bPort,bBitMask)    (bPort | bBitMask)
N#define GET_BIT_CLR(bPort,bBitMask)    (bPort & ~bBitMask)
N
N// Returns 0 if the condition is False & a non-zero value if it is True
N#define TEST_BIT_SET(bPort,bBitMask)   (bPort & bBitMask)
N#define TEST_BIT_CLR(bPort,bBitMask)   ((~bPort) & bBitMask)
N
N#endif /*__DEF_H__*/
N
L 12 "..\Common\Inc\2410lib.h" 2
N#include "memcfg.h"
L 1 "..\Common\Inc\memcfg.h" 1
N//************************************************ 
N// NAME    : memcfg.inc
N// DESC	  : Memory bank configuration file
N// Revision: 02.28.2002 ver 0.0
N//************************************************
N
N//Memory Area
N//GCS6 16bit(16MB) SDRAM(0x0c000000-0x0cffffff)
N//GCS7 16bit(16MB) SDRAM(0x0d000000-0x0dffffff)
N//          or
N//GCS6 32bit(32MB) SDRAM(0x0c000000-0x0dffffff)
N
N#ifndef __MEMCFG_H
N#define __MEMCFG_H
N 
N// BUSWIDTH : 16,32
N#define BUSWIDTH    (32)
N
N//64MB
N// 0x30000000 ~ 0x30ffffff : Download Area (16MB) Cacheable
N// 0x31000000 ~ 0x33feffff : Non-Cacheable Area
N// 0x33ff0000 ~ 0x33ff47ff : Heap & RW Area
N// 0x33ff4800 ~ 0x33ff7fff : FIQ ~ User Stack Area
N// 0x33ff8000 ~ 0x33fffeff : Not Used Area
N// 0x33ffff00 ~ 0x33ffffff : Exception & ISR Vector Table
N
N#define _RAM_STARTADDRESS       0x30000000
N#define _NONCACHE_STARTADDRESS	0x31000000
N#define _ISR_STARTADDRESS       0x33ffff00     
N#define _MMUTT_STARTADDRESS     0x33ff8000
N#define _STACK_BASEADDRESS      0x33ff8000
N#define HEAPEND                 0x33ff0000
N
N//BWSCON
N#define DW8			(0x0)
N#define DW16			(0x1)
N#define DW32			(0x2)
N#define WAIT			(0x1<<2)
N#define UBLB			(0x1<<3)
N
N//BUSWIDTH=32
N
N#define B1_BWSCON	 (DW32)
N#define B2_BWSCON	 (DW16)
N#define B3_BWSCON	 (DW16)
N#define B4_BWSCON	 (DW16)
N#define B5_BWSCON	 (DW16)
N#define B6_BWSCON	 (DW32)
N#define B7_BWSCON	 (DW32)
N    
N
N//BANK0CON 
N#define B0_Tacs			0x0	//0clk
N#define B0_Tcos			0x0	//0clk
N#define B0_Tacc			0x7	//14clk
N#define B0_Tcoh			0x0	//0clk
N#define B0_Tah			0x0	//0clk
N#define B0_Tacp			0x0	
N#define B0_PMC			0x0	//normal
N
N//BANK1CON
N#define B1_Tacs			0x0	//0clk
N#define B1_Tcos			0x0	//0clk
N#define B1_Tacc			0x7	//14clk
N#define B1_Tcoh			0x0	//0clk
N#define B1_Tah			0x0	//0clk
N#define B1_Tacp			0x0	
N#define B1_PMC			0x0	//normal
N
N//Bank 2 parameter
N#define B2_Tacs			0x0	//0clk
N#define B2_Tcos			0x0	//0clk
N#define B2_Tacc			0x7	//14clk
N#define B2_Tcoh			0x0	//0clk
N#define B2_Tah			0x0	//0clk
N#define B2_Tacp			0x0	
N#define B2_PMC			0x0	//normal
N
N//Bank 3 parameter
N#define B3_Tacs			0x0	//0clk
N#define B3_Tcos			0x0	//0clk
N#define B3_Tacc			0x7	//14clk
N#define B3_Tcoh			0x0	//0clk
N#define B3_Tah			0x0	//0clk
N#define B3_Tacp			0x0	
N#define B3_PMC			0x0	//normal
N
N//Bank 4 parameter
N#define B4_Tacs			0x0	//0clk
N#define B4_Tcos			0x0	//0clk
N#define B4_Tacc			0x7	//14clk
N#define B4_Tcoh			0x0	//0clk
N#define B4_Tah			0x0	//0clk
N#define B4_Tacp			0x0	
N#define B4_PMC			0x0	//normal
N
N//Bank 5 parameter
N#define B5_Tacs			0x0	//0clk
N#define B5_Tcos			0x0	//0clk
N#define B5_Tacc			0x7	//14clk
N#define B5_Tcoh			0x0	//0clk
N#define B5_Tah			0x0	//0clk
N#define B5_Tacp			0x0	
N#define B5_PMC			0x0	//normal
N
N//Bank 6 parameter
N#define B6_MT			0x3	//SDRAM
N//B6_Trcd			0x0	//2clk
N#define B6_Trcd			0x1	//3clk
N#define B6_SCAN			0x1	//9bit
N
N//Bank 7 parameter
N#define B7_MT			0x3	//SDRAM
N//B7_Trcd			0x0	//2clk
N#define B7_Trcd			0x1	//3clk
N#define B7_SCAN			0x1	//9bit
N
N//REFRESH parameter
N#define REFEN	  	    0x1	//Refresh enable
N#define TREFMD	  	    0x0	//CBR(CAS before RAS)/Auto refresh
N#define Trp	  	        0x0	//2clk
N#define Trc	  	        0x3	//7clk
N		
N#define Tchr			0x2	//3clk
N#define REFCNT			1113	//period=15.6us, HCLK=60Mhz, (2048+1-15.6*60)
N
N
N#endif
N
L 13 "..\Common\Inc\2410lib.h" 2
N#include "option.h"
L 1 "..\Common\Inc\option.h" 1
N/*********************************************************************************************
N* File name	: option.h
N* Author	: embest
N* Descript	: Define S3C2410 CPU Option contents 
N* History
N*********************************************************************************************/
N
N#ifndef __OPTION_H__
N#define __OPTION_H__
N
N#define FCLK 202800000
N#define HCLK (202800000/2)
N#define PCLK (202800000/4)
N#define UCLK PCLK
N
N#ifdef CLK111_50M
S#define FCLK 50000000
S#define HCLK 50000000
S#define PCLK 50000000
S#define UCLK 50000000
N#endif
N
N#ifdef CLK124_135M
S#define FCLK 135428571
S#define HCLK (135428571/2)
S#define PCLK (135428571/4)
N#endif
N
N#ifdef CLK124_200M
S#define FCLK 200000000
S#define HCLK (200000000/2)
S#define PCLK (200000000/4)
N#endif
N
N#ifdef CLK124_220M
S#define FCLK 220000000
S#define HCLK (220000000/2)
S#define PCLK (220000000/4)
N#endif
N
N#ifdef CLK124_226M
S#define FCLK 226000000
S#define HCLK (226000000/2)
S#define PCLK (226000000/4)
N#endif
N
N#ifdef CLK124_237M
S#define FCLK 237000000
S#define HCLK (237000000/2)
S#define PCLK (237000000/4)
S#define UCLK 50000000
N#endif
N
N#define FCLK_SPEED 1
N#if FCLK_SPEED==0   					//  FCLK=203Mhz, Fin=12Mhz for AUDIO     
X#if 1==0   					
S	#define M_MDIV          0xc3
S	#define M_PDIV          0x4
S	#define M_SDIV          0x1
N#elif FCLK_SPEED==1 					// Fin = 12M FCLK = 202.8Mhz M_MDIV = 0xa1 M_PDIV = 0x3 M_SDIV = 0x1
X#elif 1==1 					
N	#define M_MDIV          0xa1
N	#define M_PDIV          0x3
N	#define M_SDIV          0x1
N#endif
N
N#define PWRST             GPIO0
N#define OFFRST            GPIO1
N#define WDRST             GPIO2
N#define POWEROFFLED1	  (0x2<<4)
N#define POWEROFFLED2  	  (0x4<<4)
N#define POWEROFFLED3  	  (0x8<<4)
N
N//USB Device Options
N#define USBDMA		TRUE
N#define USBDMA_DEMAND 	FALSE			// the downloadFileSize should be (64*n)
N#define BULK_PKT_SIZE	32
N
N#endif    //__OPTION_H__	 
N
L 14 "..\Common\Inc\2410lib.h" 2
N#include "register.h"
L 1 "..\Common\Inc\register.h" 1
N/*********************************************************************************************
N* File name	: register.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*********************************************************************************************/
N
N#ifndef _S3C2410_REG_H
N#define _S3C2410_REG_H
N
N#define GPIO(Nb)	(0x00000001 << Nb)
N#define GPIO0		GPIO (0)   // GPIO  [0]	
N#define GPIO1		GPIO (1)   // GPIO  [1]		
N#define GPIO2		GPIO (2)   // GPIO  [2]	
N#define GPIO3		GPIO (3)   // GPIO  [3]	
N#define GPIO4		GPIO (4)   // GPIO  [4]		
N#define GPIO5		GPIO (5)   // GPIO  [5]			
N#define GPIO6		GPIO (6)   // GPIO  [6]			
N#define GPIO7		GPIO (7)   // GPIO  [7]			
N#define GPIO8		GPIO (8)   // GPIO  [8]			
N#define GPIO9		GPIO (9)   // GPIO  [9]			
N#define GPIO10		GPIO (10)  // GPIO [10]				
N#define GPIO11		GPIO (11)  // GPIO [11]			
N#define GPIO12		GPIO (12)  // GPIO [12]			
N#define GPIO13		GPIO (13)  // GPIO [13]				
N#define GPIO14		GPIO (14)  // GPIO [14]			
N#define GPIO15		GPIO (15)  // GPIO [15]			
N#define GPIO16		GPIO (16)  // GPIO [16]				
N#define GPIO17		GPIO (17)  // GPIO [17]			
N
N
N#define INTMSK		0x4A000008
N#define INTPND		0x4A000010
N#define INTSUBMSK	0x4A00001C
N#define WTCON		0x53000000
N#define LOCKTIME	0x4C000000
N#define MPLLCON		0x4C000004
N#define UPLLCON		0x4C000008
N#define CLKDIVN		0x4C000014
N#define BWSCON		0x48000000
N#define REFRESH		0x48000024
N#define BANKSIZE	0x48000028
N#define GPFCON		0x56000050
N#define GPFDAT		0x56000054
N#define GPFUP		0x56000058
N
N#define MISCCR		0x56000080
N#define SCK_NORMAL	(0x7<<17)
N
N#define GSTATUS0	0x560000AC
N#define GSTATUS1	0x560000B0
N#define GSTATUS2	0x560000B4
N#define GSTATUS3	0x560000B8
N#define GSTATUS4	0x560000BC    
N
N#endif
L 15 "..\Common\Inc\2410lib.h" 2
N#include "2410addr.h"
L 1 "..\Common\Inc\2410addr.h" 1
N/*********************************************************************************************
N* File name	: 2410addr.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*			R.X.Huang, Programming modify, March 12, 2005
N*********************************************************************************************/
N
N#ifndef __2410ADDR_H__
N#define __2410ADDR_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "option.h"
N
N// Memory control 
N#define rBWSCON    (*(volatile unsigned *)0x48000000) //Bus width & wait status
N#define rBANKCON0  (*(volatile unsigned *)0x48000004) //Boot ROM control
N#define rBANKCON1  (*(volatile unsigned *)0x48000008) //BANK1 control
N#define rBANKCON2  (*(volatile unsigned *)0x4800000c) //BANK2 cControl
N#define rBANKCON3  (*(volatile unsigned *)0x48000010) //BANK3 control
N#define rBANKCON4  (*(volatile unsigned *)0x48000014) //BANK4 control
N#define rBANKCON5  (*(volatile unsigned *)0x48000018) //BANK5 control
N#define rBANKCON6  (*(volatile unsigned *)0x4800001c) //BANK6 control
N#define rBANKCON7  (*(volatile unsigned *)0x48000020) //BANK7 control
N#define rREFRESH   (*(volatile unsigned *)0x48000024) //DRAM/SDRAM refresh
N#define rBANKSIZE  (*(volatile unsigned *)0x48000028) //Flexible Bank Size
N#define rMRSRB6    (*(volatile unsigned *)0x4800002c) //Mode register set for SDRAM
N#define rMRSRB7    (*(volatile unsigned *)0x48000030) //Mode register set for SDRAM
N
N
N// USB Host
N
N
N// INTERRUPT
N#define rSRCPND     (*(volatile unsigned *)0x4a000000) //Interrupt request status
N#define rINTMOD     (*(volatile unsigned *)0x4a000004) //Interrupt mode control
N#define rINTMSK     (*(volatile unsigned *)0x4a000008) //Interrupt mask control
N#define rPRIORITY   (*(volatile unsigned *)0x4a00000c) //IRQ priority control
N#define rINTPND     (*(volatile unsigned *)0x4a000010) //Interrupt request status
N#define rINTOFFSET  (*(volatile unsigned *)0x4a000014) //Interruot request source offset
N#define rSUBSRCPND  (*(volatile unsigned *)0x4a000018) //Sub source pending
N#define rINTSUBMSK  (*(volatile unsigned *)0x4a00001c) //Interrupt sub mask
N
N
N// DMA
N#define rDISRC0     (*(volatile unsigned *)0x4b000000) //DMA 0 Initial source
N#define rDISRCC0    (*(volatile unsigned *)0x4b000004) //DMA 0 Initial source control
N#define rDIDST0     (*(volatile unsigned *)0x4b000008) //DMA 0 Initial Destination
N#define rDIDSTC0    (*(volatile unsigned *)0x4b00000c) //DMA 0 Initial Destination control
N#define rDCON0      (*(volatile unsigned *)0x4b000010) //DMA 0 Control
N#define rDSTAT0     (*(volatile unsigned *)0x4b000014) //DMA 0 Status
N#define rDCSRC0     (*(volatile unsigned *)0x4b000018) //DMA 0 Current source
N#define rDCDST0     (*(volatile unsigned *)0x4b00001c) //DMA 0 Current destination
N#define rDMASKTRIG0 (*(volatile unsigned *)0x4b000020) //DMA 0 Mask trigger
N
N#define rDISRC1     (*(volatile unsigned *)0x4b000040) //DMA 1 Initial source
N#define rDISRCC1    (*(volatile unsigned *)0x4b000044) //DMA 1 Initial source control
N#define rDIDST1     (*(volatile unsigned *)0x4b000048) //DMA 1 Initial Destination
N#define rDIDSTC1    (*(volatile unsigned *)0x4b00004c) //DMA 1 Initial Destination control
N#define rDCON1      (*(volatile unsigned *)0x4b000050) //DMA 1 Control
N#define rDSTAT1     (*(volatile unsigned *)0x4b000054) //DMA 1 Status
N#define rDCSRC1     (*(volatile unsigned *)0x4b000058) //DMA 1 Current source
N#define rDCDST1     (*(volatile unsigned *)0x4b00005c) //DMA 1 Current destination
N#define rDMASKTRIG1 (*(volatile unsigned *)0x4b000060) //DMA 1 Mask trigger
N
N#define rDISRC2     (*(volatile unsigned *)0x4b000080) //DMA 2 Initial source
N#define rDISRCC2    (*(volatile unsigned *)0x4b000084) //DMA 2 Initial source control
N#define rDIDST2     (*(volatile unsigned *)0x4b000088) //DMA 2 Initial Destination
N#define rDIDSTC2    (*(volatile unsigned *)0x4b00008c) //DMA 2 Initial Destination control
N#define rDCON2      (*(volatile unsigned *)0x4b000090) //DMA 2 Control
N#define rDSTAT2     (*(volatile unsigned *)0x4b000094) //DMA 2 Status
N#define rDCSRC2     (*(volatile unsigned *)0x4b000098) //DMA 2 Current source
N#define rDCDST2     (*(volatile unsigned *)0x4b00009c) //DMA 2 Current destination
N#define rDMASKTRIG2 (*(volatile unsigned *)0x4b0000a0) //DMA 2 Mask trigger
N
N#define rDISRC3     (*(volatile unsigned *)0x4b0000c0) //DMA 3 Initial source
N#define rDISRCC3    (*(volatile unsigned *)0x4b0000c4) //DMA 3 Initial source control
N#define rDIDST3     (*(volatile unsigned *)0x4b0000c8) //DMA 3 Initial Destination
N#define rDIDSTC3    (*(volatile unsigned *)0x4b0000cc) //DMA 3 Initial Destination control
N#define rDCON3      (*(volatile unsigned *)0x4b0000d0) //DMA 3 Control
N#define rDSTAT3     (*(volatile unsigned *)0x4b0000d4) //DMA 3 Status
N#define rDCSRC3     (*(volatile unsigned *)0x4b0000d8) //DMA 3 Current source
N#define rDCDST3     (*(volatile unsigned *)0x4b0000dc) //DMA 3 Current destination
N#define rDMASKTRIG3 (*(volatile unsigned *)0x4b0000e0) //DMA 3 Mask trigger
N
N
N// CLOCK & POWER MANAGEMENT
N#define rLOCKTIME   (*(volatile unsigned *)0x4c000000) //PLL lock time counter
N#define rMPLLCON    (*(volatile unsigned *)0x4c000004) //MPLL Control
N#define rUPLLCON    (*(volatile unsigned *)0x4c000008) //UPLL Control
N#define rCLKCON     (*(volatile unsigned *)0x4c00000c) //Clock generator control
N#define rCLKSLOW    (*(volatile unsigned *)0x4c000010) //Slow clock control
N#define rCLKDIVN    (*(volatile unsigned *)0x4c000014) //Clock divider control
N
N
N// LCD CONTROLLER
N#define rLCDCON1    (*(volatile unsigned *)0x4d000000) //LCD control 1
N#define rLCDCON2    (*(volatile unsigned *)0x4d000004) //LCD control 2
N#define rLCDCON3    (*(volatile unsigned *)0x4d000008) //LCD control 3
N#define rLCDCON4    (*(volatile unsigned *)0x4d00000c) //LCD control 4
N#define rLCDCON5    (*(volatile unsigned *)0x4d000010) //LCD control 5
N#define rLCDSADDR1  (*(volatile unsigned *)0x4d000014) //STN/TFT Frame buffer start address 1
N#define rLCDSADDR2  (*(volatile unsigned *)0x4d000018) //STN/TFT Frame buffer start address 2
N#define rLCDSADDR3  (*(volatile unsigned *)0x4d00001c) //STN/TFT Virtual screen address set
N#define rREDLUT     (*(volatile unsigned *)0x4d000020) //STN Red lookup table
N#define rGREENLUT   (*(volatile unsigned *)0x4d000024) //STN Green lookup table 
N#define rBLUELUT    (*(volatile unsigned *)0x4d000028) //STN Blue lookup table
N#define rDITHMODE   (*(volatile unsigned *)0x4d00004c) //STN Dithering mode
N#define rTPAL       (*(volatile unsigned *)0x4d000050) //TFT Temporary palette
N#define rLCDINTPND  (*(volatile unsigned *)0x4d000054) //LCD Interrupt pending
N#define rLCDSRCPND  (*(volatile unsigned *)0x4d000058) //LCD Interrupt source
N#define rLCDINTMSK  (*(volatile unsigned *)0x4d00005c) //LCD Interrupt mask
N#define rLPCSEL     (*(volatile unsigned *)0x4d000060) //LPC3600 Control
N#define PALETTE     0x4d000400                         //Palette start address
N
N
N// NAND flash
N#define rNFCONF     (*(volatile unsigned *)0x4e000000)      //NAND Flash configuration
N#define rNFCMD      (*(volatile UINT8T *)0x4e000004)            //NADD Flash command
N#define rNFADDR     (*(volatile UINT8T *)0x4e000008)            //NAND Flash address
N#define rNFDATA     (*(volatile UINT8T *)0x4e00000c)            //NAND Flash data
N#define rNFSTAT     (*(volatile unsigned *)0x4e000010)      //NAND Flash operation status
N#define rNFECC      (*(volatile unsigned *)0x4e000014)      //NAND Flash ECC
N#define rNFECC0     (*(volatile UINT8T  *)0x4e000014)
N#define rNFECC1     (*(volatile UINT8T  *)0x4e000015)
N#define rNFECC2     (*(volatile UINT8T  *)0x4e000016)
N
N// UART
N#define rULCON0     (*(volatile unsigned *)0x50000000) //UART 0 Line control
N#define rUCON0      (*(volatile unsigned *)0x50000004) //UART 0 Control
N#define rUFCON0     (*(volatile unsigned *)0x50000008) //UART 0 FIFO control
N#define rUMCON0     (*(volatile unsigned *)0x5000000c) //UART 0 Modem control
N#define rUTRSTAT0   (*(volatile unsigned *)0x50000010) //UART 0 Tx/Rx status
N#define rUERSTAT0   (*(volatile unsigned *)0x50000014) //UART 0 Rx error status
N#define rUFSTAT0    (*(volatile unsigned *)0x50000018) //UART 0 FIFO status
N#define rUMSTAT0    (*(volatile unsigned *)0x5000001c) //UART 0 Modem status
N#define rUBRDIV0    (*(volatile unsigned *)0x50000028) //UART 0 Baud rate divisor
N
N#define rULCON1     (*(volatile unsigned *)0x50004000) //UART 1 Line control
N#define rUCON1      (*(volatile unsigned *)0x50004004) //UART 1 Control
N#define rUFCON1     (*(volatile unsigned *)0x50004008) //UART 1 FIFO control
N#define rUMCON1     (*(volatile unsigned *)0x5000400c) //UART 1 Modem control
N#define rUTRSTAT1   (*(volatile unsigned *)0x50004010) //UART 1 Tx/Rx status
N#define rUERSTAT1   (*(volatile unsigned *)0x50004014) //UART 1 Rx error status
N#define rUFSTAT1    (*(volatile unsigned *)0x50004018) //UART 1 FIFO status
N#define rUMSTAT1    (*(volatile unsigned *)0x5000401c) //UART 1 Modem status
N#define rUBRDIV1    (*(volatile unsigned *)0x50004028) //UART 1 Baud rate divisor
N
N#define rULCON2     (*(volatile unsigned *)0x50008000) //UART 2 Line control
N#define rUCON2      (*(volatile unsigned *)0x50008004) //UART 2 Control
N#define rUFCON2     (*(volatile unsigned *)0x50008008) //UART 2 FIFO control
N#define rUMCON2     (*(volatile unsigned *)0x5000800c) //UART 2 Modem control
N#define rUTRSTAT2   (*(volatile unsigned *)0x50008010) //UART 2 Tx/Rx status
N#define rUERSTAT2   (*(volatile unsigned *)0x50008014) //UART 2 Rx error status
N#define rUFSTAT2    (*(volatile unsigned *)0x50008018) //UART 2 FIFO status
N#define rUMSTAT2    (*(volatile unsigned *)0x5000801c) //UART 2 Modem status
N#define rUBRDIV2    (*(volatile unsigned *)0x50008028) //UART 2 Baud rate divisor
N
N#ifdef __BIG_ENDIAN
S#define rUTXH0      (*(volatile unsigned char *)0x50000023) //UART 0 Transmission Hold
S#define rURXH0      (*(volatile unsigned char *)0x50000027) //UART 0 Receive buffer
S#define rUTXH1      (*(volatile unsigned char *)0x50004023) //UART 1 Transmission Hold
S#define rURXH1      (*(volatile unsigned char *)0x50004027) //UART 1 Receive buffer
S#define rUTXH2      (*(volatile unsigned char *)0x50008023) //UART 2 Transmission Hold
S#define rURXH2      (*(volatile unsigned char *)0x50008027) //UART 2 Receive buffer
S
S#define WrUTXH0(ch) (*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
S#define RdURXH0()   (*(volatile unsigned char *)0x50000027)
S#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
S#define RdURXH1()   (*(volatile unsigned char *)0x50004027)
S#define WrUTXH2(ch) (*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
S#define RdURXH2()   (*(volatile unsigned char *)0x50008027)
S
S#define UTXH0       (0x50000020+3)  //Byte_access address by DMA
S#define URXH0       (0x50000024+3)
S#define UTXH1       (0x50004020+3)
S#define URXH1       (0x50004024+3)
S#define UTXH2       (0x50008020+3)
S#define URXH2       (0x50008024+3)
S
N#else //Little Endian
N#define rUTXH0 (*(volatile unsigned char *)0x50000020) //UART 0 Transmission Hold
N#define rURXH0 (*(volatile unsigned char *)0x50000024) //UART 0 Receive buffer
N#define rUTXH1 (*(volatile unsigned char *)0x50004020) //UART 1 Transmission Hold
N#define rURXH1 (*(volatile unsigned char *)0x50004024) //UART 1 Receive buffer
N#define rUTXH2 (*(volatile unsigned char *)0x50008020) //UART 2 Transmission Hold
N#define rURXH2 (*(volatile unsigned char *)0x50008024) //UART 2 Receive buffer
N
N#define WrUTXH0(ch) (*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
N#define RdURXH0()   (*(volatile unsigned char *)0x50000024)
N#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
N#define RdURXH1()   (*(volatile unsigned char *)0x50004024)
N#define WrUTXH2(ch) (*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
N#define RdURXH2()   (*(volatile unsigned char *)0x50008024)
N
N#define UTXH0       (0x50000020)    //Byte_access address by DMA
N#define URXH0       (0x50000024)
N#define UTXH1       (0x50004020)
N#define URXH1       (0x50004024)
N#define UTXH2       (0x50008020)
N#define URXH2       (0x50008024)
N#endif
N
N
N// PWM TIMER
N#define rTCFG0  (*(volatile unsigned *)0x51000000) //Timer 0 configuration
N#define rTCFG1  (*(volatile unsigned *)0x51000004) //Timer 1 configuration
N#define rTCON   (*(volatile unsigned *)0x51000008) //Timer control
N#define rTCNTB0 (*(volatile unsigned *)0x5100000c) //Timer count buffer 0
N#define rTCMPB0 (*(volatile unsigned *)0x51000010) //Timer compare buffer 0
N#define rTCNTO0 (*(volatile unsigned *)0x51000014) //Timer count observation 0
N#define rTCNTB1 (*(volatile unsigned *)0x51000018) //Timer count buffer 1
N#define rTCMPB1 (*(volatile unsigned *)0x5100001c) //Timer compare buffer 1
N#define rTCNTO1 (*(volatile unsigned *)0x51000020) //Timer count observation 1
N#define rTCNTB2 (*(volatile unsigned *)0x51000024) //Timer count buffer 2
N#define rTCMPB2 (*(volatile unsigned *)0x51000028) //Timer compare buffer 2
N#define rTCNTO2 (*(volatile unsigned *)0x5100002c) //Timer count observation 2
N#define rTCNTB3 (*(volatile unsigned *)0x51000030) //Timer count buffer 3
N#define rTCMPB3 (*(volatile unsigned *)0x51000034) //Timer compare buffer 3
N#define rTCNTO3 (*(volatile unsigned *)0x51000038) //Timer count observation 3
N#define rTCNTB4 (*(volatile unsigned *)0x5100003c) //Timer count buffer 4
N#define rTCNTO4 (*(volatile unsigned *)0x51000040) //Timer count observation 4
N
N
N// USB DEVICE
N#ifdef __BIG_ENDIAN
S<ERROR IF BIG_ENDIAN>
S#define rFUNC_ADDR_REG     (*(volatile unsigned char *)0x52000143) //Function address
S#define rPWR_REG           (*(volatile unsigned char *)0x52000147) //Power management
S#define rEP_INT_REG        (*(volatile unsigned char *)0x5200014b) //EP Interrupt pending and clear
S#define rUSB_INT_REG       (*(volatile unsigned char *)0x5200015b) //USB Interrupt pending and clear
S#define rEP_INT_EN_REG     (*(volatile unsigned char *)0x5200015f) //Interrupt enable
S#define rUSB_INT_EN_REG    (*(volatile unsigned char *)0x5200016f)
S#define rFRAME_NUM1_REG    (*(volatile unsigned char *)0x52000173) //Frame number lower byte
S#define rFRAME_NUM2_REG    (*(volatile unsigned char *)0x52000177) //Frame number higher byte
S#define rINDEX_REG         (*(volatile unsigned char *)0x5200017b) //Register index
S#define rMAXP_REG          (*(volatile unsigned char *)0x52000183) //Endpoint max packet
S#define rEP0_CSR           (*(volatile unsigned char *)0x52000187) //Endpoint 0 status
S#define rIN_CSR1_REG       (*(volatile unsigned char *)0x52000187) //In endpoint control status
S#define rIN_CSR2_REG       (*(volatile unsigned char *)0x5200018b)
S#define rOUT_CSR1_REG      (*(volatile unsigned char *)0x52000193) //Out endpoint control status
S#define rOUT_CSR2_REG      (*(volatile unsigned char *)0x52000197)
S#define rOUT_FIFO_CNT1_REG (*(volatile unsigned char *)0x5200019b) //Endpoint out write count
S#define rOUT_FIFO_CNT2_REG (*(volatile unsigned char *)0x5200019f)
S#define rEP0_FIFO          (*(volatile unsigned char *)0x520001c3) //Endpoint 0 FIFO
S#define rEP1_FIFO          (*(volatile unsigned char *)0x520001c7) //Endpoint 1 FIFO
S#define rEP2_FIFO          (*(volatile unsigned char *)0x520001cb) //Endpoint 2 FIFO
S#define rEP3_FIFO          (*(volatile unsigned char *)0x520001cf) //Endpoint 3 FIFO
S#define rEP4_FIFO          (*(volatile unsigned char *)0x520001d3) //Endpoint 4 FIFO
S#define rEP1_DMA_CON       (*(volatile unsigned char *)0x52000203) //EP1 DMA interface control
S#define rEP1_DMA_UNIT      (*(volatile unsigned char *)0x52000207) //EP1 DMA Tx unit counter
S#define rEP1_DMA_FIFO      (*(volatile unsigned char *)0x5200020b) //EP1 DMA Tx FIFO counter
S#define rEP1_DMA_TTC_L     (*(volatile unsigned char *)0x5200020f) //EP1 DMA total Tx counter
S#define rEP1_DMA_TTC_M     (*(volatile unsigned char *)0x52000213)
S#define rEP1_DMA_TTC_H     (*(volatile unsigned char *)0x52000217)
S#define rEP2_DMA_CON       (*(volatile unsigned char *)0x5200021b) //EP2 DMA interface control
S#define rEP2_DMA_UNIT      (*(volatile unsigned char *)0x5200021f) //EP2 DMA Tx unit counter
S#define rEP2_DMA_FIFO      (*(volatile unsigned char *)0x52000223) //EP2 DMA Tx FIFO counter
S#define rEP2_DMA_TTC_L     (*(volatile unsigned char *)0x52000227) //EP2 DMA total Tx counter
S#define rEP2_DMA_TTC_M     (*(volatile unsigned char *)0x5200022b)
S#define rEP2_DMA_TTC_H     (*(volatile unsigned char *)0x5200022f)
S#define rEP3_DMA_CON       (*(volatile unsigned char *)0x52000243) //EP3 DMA interface control
S#define rEP3_DMA_UNIT      (*(volatile unsigned char *)0x52000247) //EP3 DMA Tx unit counter
S#define rEP3_DMA_FIFO      (*(volatile unsigned char *)0x5200024b) //EP3 DMA Tx FIFO counter
S#define rEP3_DMA_TTC_L     (*(volatile unsigned char *)0x5200024f) //EP3 DMA total Tx counter
S#define rEP3_DMA_TTC_M     (*(volatile unsigned char *)0x52000253)
S#define rEP3_DMA_TTC_H     (*(volatile unsigned char *)0x52000257)
S#define rEP4_DMA_CON       (*(volatile unsigned char *)0x5200025b) //EP4 DMA interface control
S#define rEP4_DMA_UNIT      (*(volatile unsigned char *)0x5200025f) //EP4 DMA Tx unit counter
S#define rEP4_DMA_FIFO      (*(volatile unsigned char *)0x52000263) //EP4 DMA Tx FIFO counter
S#define rEP4_DMA_TTC_L     (*(volatile unsigned char *)0x52000267) //EP4 DMA total Tx counter
S#define rEP4_DMA_TTC_M     (*(volatile unsigned char *)0x5200026b)
S#define rEP4_DMA_TTC_H     (*(volatile unsigned char *)0x5200026f)
S
N#else  // Little Endian
N#define rFUNC_ADDR_REG     (*(volatile unsigned char *)0x52000140) //Function address
N#define rPWR_REG           (*(volatile unsigned char *)0x52000144) //Power management
N#define rEP_INT_REG        (*(volatile unsigned char *)0x52000148) //EP Interrupt pending and clear
N#define rUSB_INT_REG       (*(volatile unsigned char *)0x52000158) //USB Interrupt pending and clear
N#define rEP_INT_EN_REG     (*(volatile unsigned char *)0x5200015c) //Interrupt enable
N#define rUSB_INT_EN_REG    (*(volatile unsigned char *)0x5200016c)
N#define rFRAME_NUM1_REG    (*(volatile unsigned char *)0x52000170) //Frame number lower byte
N#define rFRAME_NUM2_REG    (*(volatile unsigned char *)0x52000174) //Frame number higher byte
N#define rINDEX_REG         (*(volatile unsigned char *)0x52000178) //Register index
N#define rMAXP_REG          (*(volatile unsigned char *)0x52000180) //Endpoint max packet
N#define rEP0_CSR           (*(volatile unsigned char *)0x52000184) //Endpoint 0 status
N#define rIN_CSR1_REG       (*(volatile unsigned char *)0x52000184) //In endpoint control status
N#define rIN_CSR2_REG       (*(volatile unsigned char *)0x52000188)
N#define rOUT_CSR1_REG      (*(volatile unsigned char *)0x52000190) //Out endpoint control status
N#define rOUT_CSR2_REG      (*(volatile unsigned char *)0x52000194)
N#define rOUT_FIFO_CNT1_REG (*(volatile unsigned char *)0x52000198) //Endpoint out write count
N#define rOUT_FIFO_CNT2_REG (*(volatile unsigned char *)0x5200019c)
N#define rEP0_FIFO          (*(volatile unsigned char *)0x520001c0) //Endpoint 0 FIFO
N#define rEP1_FIFO          (*(volatile unsigned char *)0x520001c4) //Endpoint 1 FIFO
N#define rEP2_FIFO          (*(volatile unsigned char *)0x520001c8) //Endpoint 2 FIFO
N#define rEP3_FIFO          (*(volatile unsigned char *)0x520001cc) //Endpoint 3 FIFO
N#define rEP4_FIFO          (*(volatile unsigned char *)0x520001d0) //Endpoint 4 FIFO
N#define rEP1_DMA_CON       (*(volatile unsigned char *)0x52000200) //EP1 DMA interface control
N#define rEP1_DMA_UNIT      (*(volatile unsigned char *)0x52000204) //EP1 DMA Tx unit counter
N#define rEP1_DMA_FIFO      (*(volatile unsigned char *)0x52000208) //EP1 DMA Tx FIFO counter
N#define rEP1_DMA_TTC_L     (*(volatile unsigned char *)0x5200020c) //EP1 DMA total Tx counter
N#define rEP1_DMA_TTC_M     (*(volatile unsigned char *)0x52000210)
N#define rEP1_DMA_TTC_H     (*(volatile unsigned char *)0x52000214)
N#define rEP2_DMA_CON       (*(volatile unsigned char *)0x52000218) //EP2 DMA interface control
N#define rEP2_DMA_UNIT      (*(volatile unsigned char *)0x5200021c) //EP2 DMA Tx unit counter
N#define rEP2_DMA_FIFO      (*(volatile unsigned char *)0x52000220) //EP2 DMA Tx FIFO counter
N#define rEP2_DMA_TTC_L     (*(volatile unsigned char *)0x52000224) //EP2 DMA total Tx counter
N#define rEP2_DMA_TTC_M     (*(volatile unsigned char *)0x52000228)
N#define rEP2_DMA_TTC_H     (*(volatile unsigned char *)0x5200022c)
N#define rEP3_DMA_CON       (*(volatile unsigned char *)0x52000240) //EP3 DMA interface control
N#define rEP3_DMA_UNIT      (*(volatile unsigned char *)0x52000244) //EP3 DMA Tx unit counter
N#define rEP3_DMA_FIFO      (*(volatile unsigned char *)0x52000248) //EP3 DMA Tx FIFO counter
N#define rEP3_DMA_TTC_L     (*(volatile unsigned char *)0x5200024c) //EP3 DMA total Tx counter
N#define rEP3_DMA_TTC_M     (*(volatile unsigned char *)0x52000250)
N#define rEP3_DMA_TTC_H     (*(volatile unsigned char *)0x52000254)
N#define rEP4_DMA_CON       (*(volatile unsigned char *)0x52000258) //EP4 DMA interface control
N#define rEP4_DMA_UNIT      (*(volatile unsigned char *)0x5200025c) //EP4 DMA Tx unit counter
N#define rEP4_DMA_FIFO      (*(volatile unsigned char *)0x52000260) //EP4 DMA Tx FIFO counter
N#define rEP4_DMA_TTC_L     (*(volatile unsigned char *)0x52000264) //EP4 DMA total Tx counter
N#define rEP4_DMA_TTC_M     (*(volatile unsigned char *)0x52000268)
N#define rEP4_DMA_TTC_H     (*(volatile unsigned char *)0x5200026c)
N#endif   // __BIG_ENDIAN
N
N
N// WATCH DOG TIMER
N#define rWTCON   (*(volatile unsigned *)0x53000000) //Watch-dog timer mode
N#define rWTDAT   (*(volatile unsigned *)0x53000004) //Watch-dog timer data
N#define rWTCNT   (*(volatile unsigned *)0x53000008) //Eatch-dog timer count
N
N
N// IIC
N#define rIICCON  (*(volatile unsigned *)0x54000000) //IIC control
N#define rIICSTAT (*(volatile unsigned *)0x54000004) //IIC status
N#define rIICADD  (*(volatile unsigned *)0x54000008) //IIC address
N#define rIICDS   (*(volatile unsigned *)0x5400000c) //IIC data shift
N
N
N// IIS
N#define rIISCON  (*(volatile unsigned *)0x55000000) //IIS Control
N#define rIISMOD  (*(volatile unsigned *)0x55000004) //IIS Mode
N#define rIISPSR  (*(volatile unsigned *)0x55000008) //IIS Prescaler
N#define rIISFCON (*(volatile unsigned *)0x5500000c) //IIS FIFO control
N
N#ifdef __BIG_ENDIAN
S#define IISFIFO  ((volatile unsigned short *)0x55000012) //IIS FIFO entry
S
N#else //Little Endian
N#define IISFIFO  ((volatile unsigned short *)0x55000010) //IIS FIFO entry
N
N#endif
N
N
N// I/O PORT 
N#define rGPACON    (*(volatile unsigned *)0x56000000) //Port A control
N#define rGPADAT    (*(volatile unsigned *)0x56000004) //Port A data
N                        
N#define rGPBCON    (*(volatile unsigned *)0x56000010) //Port B control
N#define rGPBDAT    (*(volatile unsigned *)0x56000014) //Port B data
N#define rGPBUP     (*(volatile unsigned *)0x56000018) //Pull-up control B
N                        
N#define rGPCCON    (*(volatile unsigned *)0x56000020) //Port C control
N#define rGPCDAT    (*(volatile unsigned *)0x56000024) //Port C data
N#define rGPCUP     (*(volatile unsigned *)0x56000028) //Pull-up control C
N                        
N#define rGPDCON    (*(volatile unsigned *)0x56000030) //Port D control
N#define rGPDDAT    (*(volatile unsigned *)0x56000034) //Port D data
N#define rGPDUP     (*(volatile unsigned *)0x56000038) //Pull-up control D
N                        
N#define rGPECON    (*(volatile unsigned *)0x56000040) //Port E control
N#define rGPEDAT    (*(volatile unsigned *)0x56000044) //Port E data
N#define rGPEUP     (*(volatile unsigned *)0x56000048) //Pull-up control E
N                        
N#define rGPFCON    (*(volatile unsigned *)0x56000050) //Port F control
N#define rGPFDAT    (*(volatile unsigned *)0x56000054) //Port F data
N#define rGPFUP     (*(volatile unsigned *)0x56000058) //Pull-up control F
N                        
N#define rGPGCON    (*(volatile unsigned *)0x56000060) //Port G control
N#define rGPGDAT    (*(volatile unsigned *)0x56000064) //Port G data
N#define rGPGUP     (*(volatile unsigned *)0x56000068) //Pull-up control G
N                        
N#define rGPHCON    (*(volatile unsigned *)0x56000070) //Port H control
N#define rGPHDAT    (*(volatile unsigned *)0x56000074) //Port H data
N#define rGPHUP     (*(volatile unsigned *)0x56000078) //Pull-up control H
N                        
N#define rMISCCR    (*(volatile unsigned *)0x56000080) //Miscellaneous control
N#define rDCLKCON   (*(volatile unsigned *)0x56000084) //DCLK0/1 control
N#define rEXTINT0   (*(volatile unsigned *)0x56000088) //External interrupt control register 0
N#define rEXTINT1   (*(volatile unsigned *)0x5600008c) //External interrupt control register 1
N#define rEXTINT2   (*(volatile unsigned *)0x56000090) //External interrupt control register 2
N#define rEINTFLT0  (*(volatile unsigned *)0x56000094) //Reserved
N#define rEINTFLT1  (*(volatile unsigned *)0x56000098) //Reserved
N#define rEINTFLT2  (*(volatile unsigned *)0x5600009c) //External interrupt filter control register 2
N#define rEINTFLT3  (*(volatile unsigned *)0x560000a0) //External interrupt filter control register 3
N#define rEINTMASK  (*(volatile unsigned *)0x560000a4) //External interrupt mask
N#define rEINTPEND  (*(volatile unsigned *)0x560000a8) //External interrupt pending
N#define rGSTATUS0  (*(volatile unsigned *)0x560000ac) //External pin status
N#define rGSTATUS1  (*(volatile unsigned *)0x560000b0) //Chip ID(0x32410000)
N#define rGSTATUS2  (*(volatile unsigned *)0x560000b4) //Reset type
N#define rGSTATUS3  (*(volatile unsigned *)0x560000b8) //Saved data0(32-bit) before entering POWER_OFF mode 
N#define rGSTATUS4  (*(volatile unsigned *)0x560000bc) //Saved data0(32-bit) before entering POWER_OFF mode 
N
N
N// RTC
N#ifdef __BIG_ENDIAN
S#define rRTCCON    (*(volatile unsigned char *)0x57000043) //RTC control
S#define rTICNT     (*(volatile unsigned char *)0x57000047) //Tick time count
S#define rRTCALM    (*(volatile unsigned char *)0x57000053) //RTC alarm control
S#define rALMSEC    (*(volatile unsigned char *)0x57000057) //Alarm second
S#define rALMMIN    (*(volatile unsigned char *)0x5700005b) //Alarm minute
S#define rALMHOUR   (*(volatile unsigned char *)0x5700005f) //Alarm Hour
S#define rALMDATE   (*(volatile unsigned char *)0x57000063) //Alarm day     <-- May 06, 2002 SOP
S#define rALMMON    (*(volatile unsigned char *)0x57000067) //Alarm month
S#define rALMYEAR   (*(volatile unsigned char *)0x5700006b) //Alarm year
S#define rRTCRST    (*(volatile unsigned char *)0x5700006f) //RTC round reset
S#define rBCDSEC    (*(volatile unsigned char *)0x57000073) //BCD second
S#define rBCDMIN    (*(volatile unsigned char *)0x57000077) //BCD minute
S#define rBCDHOUR   (*(volatile unsigned char *)0x5700007b) //BCD hour
S#define rBCDDATE   (*(volatile unsigned char *)0x5700007f) //BCD day       <-- May 06, 2002 SOP
S#define rBCDDAY    (*(volatile unsigned char *)0x57000083) //BCD date      <-- May 06, 2002 SOP
S#define rBCDMON    (*(volatile unsigned char *)0x57000087) //BCD month
S#define rBCDYEAR   (*(volatile unsigned char *)0x5700008b) //BCD year
S
N#else //Little Endian
N#define rRTCCON    (*(volatile unsigned char *)0x57000040) //RTC control
N#define rTICNT     (*(volatile unsigned char *)0x57000044) //Tick time count
N#define rRTCALM    (*(volatile unsigned char *)0x57000050) //RTC alarm control
N#define rALMSEC    (*(volatile unsigned char *)0x57000054) //Alarm second
N#define rALMMIN    (*(volatile unsigned char *)0x57000058) //Alarm minute
N#define rALMHOUR   (*(volatile unsigned char *)0x5700005c) //Alarm Hour
N#define rALMDATE   (*(volatile unsigned char *)0x57000060) //Alarm day      <-- May 06, 2002 SOP
N#define rALMMON    (*(volatile unsigned char *)0x57000064) //Alarm month
N#define rALMYEAR   (*(volatile unsigned char *)0x57000068) //Alarm year
N#define rRTCRST    (*(volatile unsigned char *)0x5700006c) //RTC round reset
N#define rBCDSEC    (*(volatile unsigned char *)0x57000070) //BCD second
N#define rBCDMIN    (*(volatile unsigned char *)0x57000074) //BCD minute
N#define rBCDHOUR   (*(volatile unsigned char *)0x57000078) //BCD hour
N#define rBCDDATE   (*(volatile unsigned char *)0x5700007c) //BCD day        <-- May 06, 2002 SOP
N#define rBCDDAY    (*(volatile unsigned char *)0x57000080) //BCD date       <-- May 06, 2002 SOP
N#define rBCDMON    (*(volatile unsigned char *)0x57000084) //BCD month
N#define rBCDYEAR   (*(volatile unsigned char *)0x57000088) //BCD year
N#endif  //RTC
N
N
N// ADC
N#define rADCCON    (*(volatile unsigned *)0x58000000) //ADC control
N#define rADCTSC    (*(volatile unsigned *)0x58000004) //ADC touch screen control
N#define rADCDLY    (*(volatile unsigned *)0x58000008) //ADC start or Interval Delay
N#define rADCDAT0   (*(volatile unsigned *)0x5800000c) //ADC conversion data 0
N#define rADCDAT1   (*(volatile unsigned *)0x58000010) //ADC conversion data 1                   
N                        
N// SPI          
N#define rSPCON0    (*(volatile unsigned *)0x59000000) //SPI0 control
N#define rSPSTA0    (*(volatile unsigned *)0x59000004) //SPI0 status
N#define rSPPIN0    (*(volatile unsigned *)0x59000008) //SPI0 pin control
N#define rSPPRE0    (*(volatile unsigned *)0x5900000c) //SPI0 baud rate prescaler
N#define rSPTDAT0   (*(volatile unsigned *)0x59000010) //SPI0 Tx data
N#define rSPRDAT0   (*(volatile unsigned *)0x59000014) //SPI0 Rx data
N
N#define rSPCON1    (*(volatile unsigned *)0x59000020) //SPI1 control
N#define rSPSTA1    (*(volatile unsigned *)0x59000024) //SPI1 status
N#define rSPPIN1    (*(volatile unsigned *)0x59000028) //SPI1 pin control
N#define rSPPRE1    (*(volatile unsigned *)0x5900002c) //SPI1 baud rate prescaler
N#define rSPTDAT1   (*(volatile unsigned *)0x59000030) //SPI1 Tx data
N#define rSPRDAT1   (*(volatile unsigned *)0x59000034) //SPI1 Rx data
N
N
N// SD Interface
N#define rSDICON     (*(volatile unsigned *)0x5a000000) //SDI control
N#define rSDIPRE     (*(volatile unsigned *)0x5a000004) //SDI baud rate prescaler
N#define rSDICARG    (*(volatile unsigned *)0x5a000008) //SDI command argument
N#define rSDICCON    (*(volatile unsigned *)0x5a00000c) //SDI command control
N#define rSDICSTA    (*(volatile unsigned *)0x5a000010) //SDI command status
N#define rSDIRSP0    (*(volatile unsigned *)0x5a000014) //SDI response 0
N#define rSDIRSP1    (*(volatile unsigned *)0x5a000018) //SDI response 1
N#define rSDIRSP2    (*(volatile unsigned *)0x5a00001c) //SDI response 2
N#define rSDIRSP3    (*(volatile unsigned *)0x5a000020) //SDI response 3
N#define rSDIDTIMER  (*(volatile unsigned *)0x5a000024) //SDI data/busy timer
N#define rSDIBSIZE   (*(volatile unsigned *)0x5a000028) //SDI block size
N#define rSDIDCON    (*(volatile unsigned *)0x5a00002c) //SDI data control
N#define rSDIDCNT    (*(volatile unsigned *)0x5a000030) //SDI data remain counter
N#define rSDIDSTA    (*(volatile unsigned *)0x5a000034) //SDI data status
N#define rSDIFSTA    (*(volatile unsigned *)0x5a000038) //SDI FIFO status
N#define rSDIIMSK    (*(volatile unsigned *)0x5a000040) //SDI interrupt mask
N
N#ifdef __BIG_ENDIAN
S#define rSDIDAT    (*(volatile unsigned *)0x5a00003f) //SDI data
S#define SDIDAT     0x5a00003f
N#else  // Little Endian
N#define rSDIDAT    (*(volatile unsigned *)0x5a00003c) //SDI data
N#define SDIDAT     0x5a00003c
N#endif   //SD Interface
N             
N#define _ISR_STARTADDRESS 0x33ffff00
N// ISR
N#define pISR_RESET     (*(unsigned *)(_ISR_STARTADDRESS+0x0))
N#define pISR_UNDEF     (*(unsigned *)(_ISR_STARTADDRESS+0x4))
N#define pISR_SWI       (*(unsigned *)(_ISR_STARTADDRESS+0x8))
N#define pISR_PABORT    (*(unsigned *)(_ISR_STARTADDRESS+0xc))
N#define pISR_DABORT    (*(unsigned *)(_ISR_STARTADDRESS+0x10))
N#define pISR_RESERVED  (*(unsigned *)(_ISR_STARTADDRESS+0x14))
N#define pISR_IRQ       (*(unsigned *)(_ISR_STARTADDRESS+0x18))
N#define pISR_FIQ       (*(unsigned *)(_ISR_STARTADDRESS+0x1c))
N
N#define pISR_EINT0     (*(unsigned *)(_ISR_STARTADDRESS+0x20))
N#define pISR_EINT1     (*(unsigned *)(_ISR_STARTADDRESS+0x24))
N#define pISR_EINT2     (*(unsigned *)(_ISR_STARTADDRESS+0x28))
N#define pISR_EINT3     (*(unsigned *)(_ISR_STARTADDRESS+0x2c))
N#define pISR_EINT4_7   (*(unsigned *)(_ISR_STARTADDRESS+0x30))
N#define pISR_EINT8_23  (*(unsigned *)(_ISR_STARTADDRESS+0x34))
N#define pISR_NOTUSED6  (*(unsigned *)(_ISR_STARTADDRESS+0x38))
N#define pISR_BAT_FLT   (*(unsigned *)(_ISR_STARTADDRESS+0x3c))
N#define pISR_TICK      (*(unsigned *)(_ISR_STARTADDRESS+0x40))
N#define pISR_WDT       (*(unsigned *)(_ISR_STARTADDRESS+0x44))
N#define pISR_TIMER0    (*(unsigned *)(_ISR_STARTADDRESS+0x48))
N#define pISR_TIMER1    (*(unsigned *)(_ISR_STARTADDRESS+0x4c))
N#define pISR_TIMER2    (*(unsigned *)(_ISR_STARTADDRESS+0x50))
N#define pISR_TIMER3    (*(unsigned *)(_ISR_STARTADDRESS+0x54))
N#define pISR_TIMER4    (*(unsigned *)(_ISR_STARTADDRESS+0x58))
N#define pISR_UART2     (*(unsigned *)(_ISR_STARTADDRESS+0x5c))
N#define pISR_LCD       (*(unsigned *)(_ISR_STARTADDRESS+0x60))
N#define pISR_DMA0      (*(unsigned *)(_ISR_STARTADDRESS+0x64))
N#define pISR_DMA1      (*(unsigned *)(_ISR_STARTADDRESS+0x68))
N#define pISR_DMA2      (*(unsigned *)(_ISR_STARTADDRESS+0x6c))
N#define pISR_DMA3      (*(unsigned *)(_ISR_STARTADDRESS+0x70))
N#define pISR_SDI       (*(unsigned *)(_ISR_STARTADDRESS+0x74))
N#define pISR_SPI0      (*(unsigned *)(_ISR_STARTADDRESS+0x78))
N#define pISR_UART1     (*(unsigned *)(_ISR_STARTADDRESS+0x7c))
N#define pISR_NOTUSED24 (*(unsigned *)(_ISR_STARTADDRESS+0x80))
N#define pISR_USBD      (*(unsigned *)(_ISR_STARTADDRESS+0x84))
N#define pISR_USBH      (*(unsigned *)(_ISR_STARTADDRESS+0x88))
N#define pISR_IIC       (*(unsigned *)(_ISR_STARTADDRESS+0x8c))
N#define pISR_UART0     (*(unsigned *)(_ISR_STARTADDRESS+0x90))
N#define pISR_SPI1      (*(unsigned *)(_ISR_STARTADDRESS+0x94))
N#define pISR_RTC       (*(unsigned *)(_ISR_STARTADDRESS+0x98))
N#define pISR_ADC       (*(unsigned *)(_ISR_STARTADDRESS+0x9c))
N
N
N// PENDING BIT
N#define BIT_EINT0      (0x1)
N#define BIT_EINT1      (0x1<<1)
N#define BIT_EINT2      (0x1<<2)
N#define BIT_EINT3      (0x1<<3)
N#define BIT_EINT4_7    (0x1<<4)
N#define BIT_EINT8_23   (0x1<<5)
N#define BIT_NOTUSED6   (0x1<<6)
N#define BIT_BAT_FLT    (0x1<<7)
N#define BIT_TICK       (0x1<<8)
N#define BIT_WDT        (0x1<<9)
N#define BIT_TIMER0     (0x1<<10)
N#define BIT_TIMER1     (0x1<<11)
N#define BIT_TIMER2     (0x1<<12)
N#define BIT_TIMER3     (0x1<<13)
N#define BIT_TIMER4     (0x1<<14)
N#define BIT_UART2      (0x1<<15)
N#define BIT_LCD        (0x1<<16)
N#define BIT_DMA0       (0x1<<17)
N#define BIT_DMA1       (0x1<<18)
N#define BIT_DMA2       (0x1<<19)
N#define BIT_DMA3       (0x1<<20)
N#define BIT_SDI        (0x1<<21)
N#define BIT_SPI0       (0x1<<22)
N#define BIT_UART1      (0x1<<23)
N#define BIT_NOTUSED24  (0x1<<24)
N#define BIT_USBD       (0x1<<25)
N#define BIT_USBH       (0x1<<26)
N#define BIT_IIC        (0x1<<27)
N#define BIT_UART0      (0x1<<28)
N#define BIT_SPI1       (0x1<<29)
N#define BIT_RTC        (0x1<<30)
N#define BIT_ADC        (0x80000000) //(0x1<<31)
N#define BIT_ALLMSK     (0xffffffff)
N
N#define BIT_SUB_ALLMSK (0x7ff)
N#define BIT_SUB_ADC    (0x1<<10)
N#define BIT_SUB_TC     (0x1<<9)
N#define BIT_SUB_ERR2   (0x1<<8)
N#define BIT_SUB_TXD2   (0x1<<7)
N#define BIT_SUB_RXD2   (0x1<<6)
N#define BIT_SUB_ERR1   (0x1<<5)
N#define BIT_SUB_TXD1   (0x1<<4)
N#define BIT_SUB_RXD1   (0x1<<3)
N#define BIT_SUB_ERR0   (0x1<<2)
N#define BIT_SUB_TXD0   (0x1<<1)
N#define BIT_SUB_RXD0   (0x1<<0)
N
N#define ClearPending(bit) {\
N                rSRCPND = bit;\
N                rINTPND = rINTPND;} // precent write wrong data
X#define ClearPending(bit) {                rSRCPND = bit;                rINTPND = rINTPND;} 
N
N//Wait until rINTPND is changed for the case that the ISR is very short.
N
N#ifdef __cplusplus
S}
N#endif
N#endif  //__2410ADDR_H___
N
L 16 "..\Common\Inc\2410lib.h" 2
N
N#ifndef __2410lib_h__
N#define __2410lib_h__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								constant define						 				    */
N/*------------------------------------------------------------------------------------------*/
N#define DOWNLOAD_ADDRESS _RAM_STARTADDRESS
N#define DEBUG_OUT uart_printf
N
N#define min(x1,x2) (((x1)<(x2))? (x1):(x2))
N#define max(x1,x2) (((x1)>(x2))? (x1):(x2))
N
N#define ONESEC0 (62500)								// 16us resolution, max 1.04 sec
N#define ONESEC1 (31250)								// 32us resolution, max 2.09 sec
N#define ONESEC2 (15625)								// 64us resolution, max 4.19 sec
N#define ONESEC3 (7812)								// 128us resolution, max 8.38 sec
N#define ONESEC4 (PCLK/128/(0xff+1))					// @60Mhz, 128*4us resolution, max 32.53 sec
N
N#define NULL 0
N#define LCD   0xDD									// LCD symbol
N#define UART0 0x0									// UART symbol
N#define UART1 0x1
N#define UART2 0xBB
N#define EnterPWDN(clkcon) ((void (*)(int))0x20)(clkcon)
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								fuction declare						 				    */
N/*------------------------------------------------------------------------------------------*/
Nvoid StartPointAfterPowerOffWakeUp(void);  
Nvoid sys_init(void);
Nvoid delay(int time);								// Watchdog Timer is used.
Nvoid port_init(void);
Nvoid uart_select(int ch);
Nvoid uart_txempty(int ch);
Nvoid uart_init(int nMainClk, int nBaud, int nChannel);
Nchar uart_getch(void);
Nchar uart_getkey(void);
Nint  uart_getintnum(void);
Nvoid uart_sendbyte(int data);
Nvoid uart_printf(char *fmt,...);
Nvoid uart_sendstring(char *pt);
Nvoid timer_start(int divider);						// Watchdog Timer is used.
Nint  timer_stop(void);								// Watchdog Timer is used.
N
Nvoid led_display(int data);
N
Nvoid change_value_MPLL(int m,int p,int s);
Nvoid change_clock_divider(int hdivn,int pdivn);
Nvoid ChangeUPllValue(int m,int p,int s);
Nvoid InitMMU(unsigned int *pTranslationTable);		
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								inline fuction define								    */
N/*------------------------------------------------------------------------------------------*/
N/*********************************************************************************************
N* name:		ARM_WriteTTB
N* func:		Write Translation table base  register
N* para:		TTB Address
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteTTB(unsigned int ttb)
N{
N 	__asm("MCR p15, 0, (ttb & 0xFFFFC000), c2, c0, 0");
N}
N
N/*********************************************************************************************
N* name:		ARM_WriteDomain
N* func:		Write domain access control
N* para:		Domain NO.
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteDomain(unsigned int domain)
N{
N 	__asm("MCR p15, 0, domain, c3, c0, 0");
N}
N
N/*********************************************************************************************
N* name:		ARM_ReadControl
N* func:		Read Control register
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline unsigned int ARM_ReadControl()
N{
N	register unsigned int ctl;
N 	__asm("MRC p15, 0, ctl, c1, c0, 0");
N 	return ctl;
N}
N
N/*********************************************************************************************
N* name:		ARM_WriteControl
N* func:		Write Control register
N* para:		Control Byte
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteControl(unsigned int ctl)
N{
N 	__asm("MCR p15, 0, ctl, c1, c0, 0");
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__2410lib_h__
N
L 13 "Source\lcdlib.c" 2
N#include "lcdlib.h"
L 1 ".\Include\lcdlib.h" 1
N/*********************************************************************************************
N* File	lcdlib.h
N* Author:	Embest	
N* Desc	header file of lcd lib 
N* History:	
N*			Y.J.Guo, Programming modify, April 12, 2005
N*********************************************************************************************/
N#ifndef __LCDLIB_H__
N#define __LCDLIB_H__
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								macro define						 				    */
N/*------------------------------------------------------------------------------------------*/
N#define BLACK 0x0
N#define WHITE 0xffff
N#define RED 0xf800
N#define GREEN 0x7e0
N#define BLUE 0x10
N#define ALLBLACK ((BLACK << 24) | (BLACK << 16) | (BLACK << 8) | BLACK)
N#define ALLWHITE ((WHITE << 24)  | (WHITE << 16)  | (WHITE << 8)  | WHITE)
N#define LIGHTGRAY    0xa0
N#define DARKGRAY     0x50
N#define TRANSPARENCY 0xff
N
N
N#define MVAL		(13)
N#define MVAL_USED 	(0)
N#define M5D(n) ((n) & 0x1fffff)                                 // To get lower 21bits
N#define GUISWAP(a, b){a^=b; b^=a; a^=b;}
N
N//STN LCD Panel(320*240)
N#define MODE_STN_1BIT 	(0x1001)
N#define MODE_STN_2BIT  	(0x1002)
N#define MODE_STN_4BIT  	(0x1004)
N//Color STN LCD Panel(320*240)
N#define MODE_CSTN_8BIT   (0x2001)
N#define MODE_CSTN_12BIT (0x2002)
N//TFT LCD Panel(240*320)
N#define MODE_TFT_1BIT_240320     (0x4101)
N#define MODE_TFT_8BIT_240320 	 (0x4102)
N#define MODE_TFT_16BIT_240320    (0x4104)
N//TFT LCD Panel(640*480)
N#define MODE_TFT_1BIT_640480     (0x4201)
N#define MODE_TFT_8BIT_640480     (0x4202)
N#define MODE_TFT_16BIT_640480    (0x4204)
N#define MODE_TFT_16BIT_800480    (0x4208)
N#define MODE_TFT_24BIT_640480    (0x42016)
N//TFT LCD Panel(800*600)
N#define MODE_TFT_1BIT_800600     (0x4401)
N#define MODE_TFT_8BIT_800600     (0x4402)
N#define MODE_TFT_16BIT_800600    (0x4404)
N
N//STN
N#define LCD_XSIZE_STN 	(320)
N#define LCD_YSIZE_STN 	(240)
N//Color STN
N#define LCD_XSIZE_CSTN 	(320)
N#define LCD_YSIZE_CSTN 	(240)
N//TFT 240320
N#define LCD_XSIZE_TFT_240320 	(240)	
N#define LCD_YSIZE_TFT_240320 	(320)
N//TFT 640480
N#define LCD_XSIZE_TFT_640480 	(640)	
N#define LCD_YSIZE_TFT_640480 	(480)
N//TFT 800480
N#define LCD_XSIZE_TFT_800480 	(800)	
N#define LCD_YSIZE_TFT_800480 	(480)
N//TFT 800600
N#define LCD_XSIZE_TFT_800600 	(800)	
N#define LCD_YSIZE_TFT_800600 	(600)
N//STN
N#define SCR_XSIZE_STN 	(LCD_XSIZE_STN*2)                       //for virtual screen  
N#define SCR_YSIZE_STN 	(LCD_YSIZE_STN*2)
N//Color STN
N#define SCR_XSIZE_CSTN 	(LCD_XSIZE_CSTN*2)        				//for virtual screen  
N#define SCR_YSIZE_CSTN 	(LCD_YSIZE_CSTN*2)
N//TFT 240320
N#define SCR_XSIZE_TFT_240320 	(LCD_XSIZE_TFT_240320*2)
N#define SCR_YSIZE_TFT_240320 	(LCD_YSIZE_TFT_240320*2)
N//TFT 640480
N#define SCR_XSIZE_TFT_640480 	(LCD_XSIZE_TFT_640480*2)
N#define SCR_YSIZE_TFT_640480 	(LCD_YSIZE_TFT_640480*2)
N//TFT 800480
N#define SCR_XSIZE_TFT_800480 	(LCD_XSIZE_TFT_800480*2)
N#define SCR_YSIZE_TFT_800480 	(LCD_YSIZE_TFT_800480*2)
N//TFT 800600
N#define SCR_XSIZE_TFT_800600 	(LCD_XSIZE_TFT_800600*2)
N#define SCR_YSIZE_TFT_800600 	(LCD_YSIZE_TFT_800600*2)
N
N//STN
N#define HOZVAL_STN		(LCD_XSIZE_STN/4-1)	                    // Valid VD data line number is 4.
N#define LINEVAL_STN		(LCD_YSIZE_STN-1)
N//Color STN
N#define HOZVAL_CSTN		(LCD_XSIZE_CSTN*3/8-1)	                // Valid VD data line number is 8.
N#define LINEVAL_CSTN		(LCD_YSIZE_CSTN-1)
N//TFT240320
N#define HOZVAL_TFT_240320	(LCD_XSIZE_TFT_240320-1)
N#define LINEVAL_TFT_240320	(LCD_YSIZE_TFT_240320-1)
N//TFT640480
N#define HOZVAL_TFT_640480	(LCD_XSIZE_TFT_640480-1)
N#define LINEVAL_TFT_640480	(LCD_YSIZE_TFT_640480-1)
N//TFT800480
N#define HOZVAL_TFT_800480	(LCD_XSIZE_TFT_800480-1)
N#define LINEVAL_TFT_800480	(LCD_YSIZE_TFT_800480-1)
N//TFT800600
N#define HOZVAL_TFT_800600	(LCD_XSIZE_TFT_800600-1)
N#define LINEVAL_TFT_800600	(LCD_YSIZE_TFT_800600-1)
N
N//STN
N#define WLH_STN	    		(0)
N#define WDLY_STN		(0)
N#define LINEBLANK_MONO		(1 &0xff)                           // MONO timing parameter for CPT CLS-040S-C3M(CHUNGHWA)
N#define LINEBLANK_GRAY		(13 &0xff)                          // GRAY timing parameter for CPT CLS-040S-C3M(CHUNGHWA)
N//CSTN timing parameter for LCBHBT161M(NANYA)
N#define WLH_CSTN	        (0)
N#define WDLY_CSTN		(0)
N#define LINEBLANK_CSTN		(16 &0xff)
N//Timing parameter for LTS350Q1(SAMSUNG) 
N#define VBPD_240320		((2-1)&0xff)
N#define VFPD_240320		((3-1)&0xff)
N#define VSPW_240320		((2-1) &0x3f)
N#define HBPD_240320		((7-1)&0x7f)
N#define HFPD_240320		((3-1)&0xff)
N#define HSPW_240320		((4-1)&0xff)
N//Timing parameter for V16C6448AB(PRIME VIEW) 
N#define VBPD_640480		((33-1)&0xff)
N#define VFPD_640480		((10-1)&0xff)
N#define VSPW_640480		((2-1) &0x3f)
N#define HBPD_640480		((48-1)&0x7f)
N#define HFPD_640480		((16-1)&0xff)
N#define HSPW_640480		((96-1)&0xff)
N
N#define VBPD_800480		((15)&0xff)//
N#define VFPD_800480		((15)&0xff)//
N#define VSPW_800480		((30) &0x3f)//
N#define HBPD_800480		((30)&0x7f)//
N#define HFPD_800480		((70)&0xff)//
N#define HSPW_800480		((100)&0xff)//
N
N//Timing parameter for LP104S5-B2AP(LGPHILIPS) 
N#define VBPD_800600        	((2-1)&0xff)
N#define VFPD_800600		((3-1)&0xff)
N#define VSPW_800600		((1-1) &0x3f)
N#define HBPD_800600		((30-1)&0x7f)
N#define HFPD_800600		((30-1)&0xff)
N#define HSPW_800600		((12-1)&0xff)
N
N
N#define CLKVAL_STN_MONO		(20) 	
N    // 64hz @50Mhz,WLH=16hclk,WDLY=16hclk,LINEBLANK=1*8hclk,VD=4 
N#define CLKVAL_STN_GRAY		(10) 	
N    // 120hz @50Mhz,WLH=16hclk,WDLY=16hclk,LINEBLANK=13*8hclk,VD=4 
N#define CLKVAL_CSTN		(6) 	
N    // 130hz @50Mhz,WLH=16hclk,WDLY=16hclk,LINEBLANK=16*8hclk,VD=8  
N#define CLKVAL_TFT_240320	(4) 	
N    // 60hz @50Mhz
N    //VSYNC,HSYNC should be inverted
N    //HBPD=6VCLK,HFPD=2VCLK,HSPW=3VCLK
N    //VBPD=1HSYNC,VFPD=2HSYNC,VSPW=1HSYNC
N#define CLKVAL_TFT_640480 	(1)
N    //53.5hz @90Mhz
N    //VSYNC,HSYNC should be inverted
N    //HBPD=47VCLK,HFPD=15VCLK,HSPW=95VCLK
N    //VBPD=32HSYNC,VFPD=9HSYNC,VSPW=1HSYNC
N#define CLKVAL_TFT_800480 	(0)
N#define CLKVAL_TFT_800600 	(0)
N    //85hz @90Mhz
N    //71hz @76Mhz
N    //VSYNC,HSYNC should be inverted
N    //HBPD=29VCLK,HFPD=29VCLK,HSPW=11VCLK
N    //VBPD=1HSYNC,VFPD=2HSYNC,VSPW=0HSYNC
N#define LCDFRAMEBUFFER 0x31000000 //_NONCACHE_STARTADDRESS 
N    // 1. The LCD frame buffer should be write-through or non-cachable.
N    // 2. The total frame memory should be inside 4MB.
N    // 3. To meet above 2 conditions, the frame buffer should be 
N    // inside the following regions.
N    // 0x31000000~0x313ffffff,
N    // 0x31400000~0x317ffffff,
N    // 0x31800000~0x31bffffff,
N    //        .....    
N    // 0x33800000~0x33bffffff                
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								external variables					 				    */
N/*------------------------------------------------------------------------------------------*/
N//Mono
Nextern UINT32T (*frameBuffer1Bit)[SCR_XSIZE_STN/32];
Xextern unsigned int (*frameBuffer1Bit)[((320)*2)/32];
N//Gray
Nextern UINT32T (*frameBuffer2Bit)[SCR_XSIZE_STN/16];
Xextern unsigned int (*frameBuffer2Bit)[((320)*2)/16];
Nextern UINT32T (*frameBuffer4Bit)[SCR_XSIZE_STN/8];
Xextern unsigned int (*frameBuffer4Bit)[((320)*2)/8];
N//Color STN
Nextern UINT32T (*frameBuffer8Bit)[SCR_XSIZE_CSTN/4];
Xextern unsigned int (*frameBuffer8Bit)[((320)*2)/4];
Nextern UINT32T (*frameBuffer12Bit)[SCR_XSIZE_CSTN*3/8];             // The least common multiple (between 12 and 32) is 96
Xextern unsigned int (*frameBuffer12Bit)[((320)*2)*3/8];             
N//TFT 240320
Nextern UINT32T (*frameBuffer8BitTft240320)[SCR_XSIZE_TFT_240320/4];
Xextern unsigned int (*frameBuffer8BitTft240320)[((240)*2)/4];
Nextern UINT32T (*frameBuffer16BitTft240320)[SCR_XSIZE_TFT_240320/2];
Xextern unsigned int (*frameBuffer16BitTft240320)[((240)*2)/2];
N//TFT 640480
Nextern UINT32T (*frameBuffer1BitTft640480)[SCR_XSIZE_TFT_640480/32];
Xextern unsigned int (*frameBuffer1BitTft640480)[((640)*2)/32];
Nextern UINT32T (*frameBuffer8BitTft640480)[SCR_XSIZE_TFT_640480/4];
Xextern unsigned int (*frameBuffer8BitTft640480)[((640)*2)/4];
Nextern UINT32T (*frameBuffer16BitTft640480)[SCR_XSIZE_TFT_640480/2];
Xextern unsigned int (*frameBuffer16BitTft640480)[((640)*2)/2];
Nextern UINT32T (*frameBuffer16BitTft800480)[SCR_XSIZE_TFT_800480/2];
Xextern unsigned int (*frameBuffer16BitTft800480)[((800)*2)/2];
Nextern UINT32T (*frameBuffer24BitTft640480)[SCR_XSIZE_TFT_640480];  // Unpacked 24bit 
Xextern unsigned int (*frameBuffer24BitTft640480)[((640)*2)];  
N//TFT 800600
Nextern UINT32T (*frameBuffer1BitTft800600)[SCR_XSIZE_TFT_800600/32];
Xextern unsigned int (*frameBuffer1BitTft800600)[((800)*2)/32];
Nextern UINT32T (*frameBuffer8BitTft800600)[SCR_XSIZE_TFT_800600/4];
Xextern unsigned int (*frameBuffer8BitTft800600)[((800)*2)/4];
Nextern UINT32T (*frameBuffer16BitTft800600)[SCR_XSIZE_TFT_800600/2];
Xextern unsigned int (*frameBuffer16BitTft800600)[((800)*2)/2];
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								function declare                                        */
N/*------------------------------------------------------------------------------------------*/
Nvoid Lcd_Init(int type);
Nvoid MoveViewPort(int);
Nvoid Lcd_CstnOnOff(int onoff);
Nvoid Lcd_EnvidOnOff(int onoff);
Nvoid Lcd_PowerEnable(int invpwren,int pwren);
Nvoid Lcd_MoveViewPort(int vx,int vy,int type);
Nvoid Lcd_Lpc3600Enable(void);
N
N
N#endif                                                          //__LCDLIB_H__
L 14 "Source\lcdlib.c" 2
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								variables define					 				    */
N/*------------------------------------------------------------------------------------------*/
N//Mono STN
NUINT32T (*frameBuffer1Bit)[SCR_XSIZE_STN/32];
Xunsigned int (*frameBuffer1Bit)[((320)*2)/32];
N//Gray
NUINT32T (*frameBuffer2Bit)[SCR_XSIZE_STN/16];
Xunsigned int (*frameBuffer2Bit)[((320)*2)/16];
NUINT32T (*frameBuffer4Bit)[SCR_XSIZE_STN/8];
Xunsigned int (*frameBuffer4Bit)[((320)*2)/8];
N//Color STN
NUINT32T (*frameBuffer8Bit)[SCR_XSIZE_CSTN/4];
Xunsigned int (*frameBuffer8Bit)[((320)*2)/4];
NUINT32T (*frameBuffer12Bit)[SCR_XSIZE_CSTN*3/8];                //4096STN38
Xunsigned int (*frameBuffer12Bit)[((320)*2)*3/8];                
N//TFT 240320
NUINT32T (*frameBuffer8BitTft240320)[SCR_XSIZE_TFT_240320/4];
Xunsigned int (*frameBuffer8BitTft240320)[((240)*2)/4];
NUINT32T (*frameBuffer16BitTft240320)[SCR_XSIZE_TFT_240320/2];
Xunsigned int (*frameBuffer16BitTft240320)[((240)*2)/2];
N//TFT 640480
NUINT32T (*frameBuffer1BitTft640480)[SCR_XSIZE_TFT_640480/32];
Xunsigned int (*frameBuffer1BitTft640480)[((640)*2)/32];
NUINT32T (*frameBuffer8BitTft640480)[SCR_XSIZE_TFT_640480/4];
Xunsigned int (*frameBuffer8BitTft640480)[((640)*2)/4];
NUINT32T (*frameBuffer16BitTft640480)[SCR_XSIZE_TFT_640480/2];
Xunsigned int (*frameBuffer16BitTft640480)[((640)*2)/2];
NUINT32T (*frameBuffer16BitTft800480)[SCR_XSIZE_TFT_800480/2];
Xunsigned int (*frameBuffer16BitTft800480)[((800)*2)/2];
NUINT32T (*frameBuffer24BitTft640480)[SCR_XSIZE_TFT_640480];
Xunsigned int (*frameBuffer24BitTft640480)[((640)*2)];
N//TFT 800600
NUINT32T (*frameBuffer1BitTft800600)[SCR_XSIZE_TFT_800600/32];
Xunsigned int (*frameBuffer1BitTft800600)[((800)*2)/32];
NUINT32T (*frameBuffer8BitTft800600)[SCR_XSIZE_TFT_800600/4];
Xunsigned int (*frameBuffer8BitTft800600)[((800)*2)/4];
NUINT32T (*frameBuffer16BitTft800600)[SCR_XSIZE_TFT_800600/2];
Xunsigned int (*frameBuffer16BitTft800600)[((800)*2)/2];
N
N/*********************************************************************************************
N* name:		Lcd_Init
N* func:		lcd initialization code 
N* para:		int type -- lcd display mode
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid Lcd_Init(int type)
N{
N    switch(type)
N    {
N        case MODE_STN_1BIT:
X        case (0x1001):
N       	    frameBuffer1Bit=(UINT32T (*)[SCR_XSIZE_STN/32])LCDFRAMEBUFFER;
X       	    frameBuffer1Bit=(unsigned int (*)[((320)*2)/32])0x31000000;
N       	
N       	    //CLKVAL_STN_MONO(20) MVAL_USED:(0)41bpp STNENVID=off
N    	    rLCDCON1=(CLKVAL_STN_MONO<<8)|(MVAL_USED<<7)|(1<<5)|(0<<1)|0;
X    	    (*(volatile unsigned *)0x4d000000)=((20)<<8)|((0)<<7)|(1<<5)|(0<<1)|0;
N
N   	        //LINEVAL_STN(LCD_YSIZE_STN(240)-1STN LCD0
N	        rLCDCON2=(0<<24)|(LINEVAL_STN<<14)|(0<<6)|(0<<0);	// It is not TFT LCD. So,.....    		
X	        (*(volatile unsigned *)0x4d000004)=(0<<24)|(((240)-1)<<14)|(0<<6)|(0<<0);	
N	    
N	        //WDLY_STN0   HOZVAL_STNLCD_XSIZE_STN/4-1   LINEBLANK_MONO(1 &0xff)
N    	    rLCDCON3=(WDLY_STN<<19)|(HOZVAL_STN<<8)|(LINEBLANK_MONO<<0);
X    	    (*(volatile unsigned *)0x4d000008)=((0)<<19)|(((320)/4-1)<<8)|((1 &0xff)<<0);
N	    
N    	    //MVAL13  WLH_STN0
N    	    rLCDCON4=(MVAL<<8)|(WLH_STN<<0);
X    	    (*(volatile unsigned *)0x4d00000c)=((13)<<8)|((0)<<0);
N    
N    	    rLCDCON5=0;
X    	    (*(volatile unsigned *)0x4d000010)=0;
N	    
N	        rLCDSADDR1=(((UINT32T)frameBuffer1Bit>>22)<<21)|M5D((UINT32T)frameBuffer1Bit>>1);		
X	        (*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer1Bit>>22)<<21)|(((unsigned int)frameBuffer1Bit>>1) & 0x1fffff);		
N	        rLCDSADDR2=M5D(((UINT32T)frameBuffer1Bit+(SCR_XSIZE_STN*LCD_YSIZE_STN/8))>>1);
X	        (*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer1Bit+(((320)*2)*(240)/8))>>1) & 0x1fffff);
N	        rLCDSADDR3=(((SCR_XSIZE_STN-LCD_XSIZE_STN)/16)<<11)|(LCD_XSIZE_STN/16);
X	        (*(volatile unsigned *)0x4d00001c)=(((((320)*2)-(320))/16)<<11)|((320)/16);
N      
N            break;
N
N        case MODE_STN_2BIT:
X        case (0x1002):
N    	    frameBuffer2Bit=(UINT32T (*)[SCR_XSIZE_STN/16])LCDFRAMEBUFFER;
X    	    frameBuffer2Bit=(unsigned int (*)[((320)*2)/16])0x31000000;
N    	    rLCDCON1=(CLKVAL_STN_GRAY<<8)|(MVAL_USED<<7)|(1<<5)|(1<<1)|0;
X    	    (*(volatile unsigned *)0x4d000000)=((10)<<8)|((0)<<7)|(1<<5)|(1<<1)|0;
N   	        
N   	        // 4-bit single scan,2bpp STN,ENVID=off
N    	    rLCDCON2=(0<<24)|(LINEVAL_STN<<14)|(0<<6)|(0<<0);
X    	    (*(volatile unsigned *)0x4d000004)=(0<<24)|(((240)-1)<<14)|(0<<6)|(0<<0);
N    	    rLCDCON3=(WDLY_STN<<19)|(HOZVAL_STN<<8)|(LINEBLANK_GRAY<<0);
X    	    (*(volatile unsigned *)0x4d000008)=((0)<<19)|(((320)/4-1)<<8)|((13 &0xff)<<0);
N    	    rLCDCON4=(MVAL<<8)|(WLH_STN<<0);
X    	    (*(volatile unsigned *)0x4d00000c)=((13)<<8)|((0)<<0);
N    	    rLCDCON5=0;
X    	    (*(volatile unsigned *)0x4d000010)=0;
N
N    	    rLCDSADDR1=(((UINT32T)frameBuffer2Bit>>22)<<21)|M5D((UINT32T)frameBuffer2Bit>>1);
X    	    (*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer2Bit>>22)<<21)|(((unsigned int)frameBuffer2Bit>>1) & 0x1fffff);
N    	    rLCDSADDR2=M5D( ((UINT32T)frameBuffer2Bit+(SCR_XSIZE_STN*LCD_YSIZE_STN/4))>>1);
X    	    (*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer2Bit+(((320)*2)*(240)/4))>>1) & 0x1fffff);
N    	    rLCDSADDR3=(((SCR_XSIZE_STN-LCD_XSIZE_STN)/8)<<11)|(LCD_XSIZE_STN/8);
X    	    (*(volatile unsigned *)0x4d00001c)=(((((320)*2)-(320))/8)<<11)|((320)/8);
N	        rDITHMODE=0x0;
X	        (*(volatile unsigned *)0x4d00004c)=0x0;
N	        rBLUELUT =0xf950;                                   // 4-Gray only
X	        (*(volatile unsigned *)0x4d000028) =0xf950;                                   
N      
N            break;
N    	
N        case MODE_STN_4BIT:
X        case (0x1004):
N    	    frameBuffer4Bit=(UINT32T (*)[SCR_XSIZE_STN/8])LCDFRAMEBUFFER;
X    	    frameBuffer4Bit=(unsigned int (*)[((320)*2)/8])0x31000000;
N    	    rLCDCON1=(CLKVAL_STN_GRAY<<8)|(MVAL_USED<<7)|(1<<5)|(2<<1)|0;
X    	    (*(volatile unsigned *)0x4d000000)=((10)<<8)|((0)<<7)|(1<<5)|(2<<1)|0;
N    	    
N    	    // 4-bit single scan,4bpp STN,ENVID=off
N	        rLCDCON2=(0<<24)|(LINEVAL_STN<<14)|(0<<6)|(0<<0);
X	        (*(volatile unsigned *)0x4d000004)=(0<<24)|(((240)-1)<<14)|(0<<6)|(0<<0);
N	        rLCDCON3=(WDLY_STN<<19)|(HOZVAL_STN<<8)|(LINEBLANK_GRAY<<0);
X	        (*(volatile unsigned *)0x4d000008)=((0)<<19)|(((320)/4-1)<<8)|((13 &0xff)<<0);
N	        rLCDCON4=(MVAL<<8)|(WLH_STN<<0);
X	        (*(volatile unsigned *)0x4d00000c)=((13)<<8)|((0)<<0);
N	        rLCDCON5=0;
X	        (*(volatile unsigned *)0x4d000010)=0;
N 
N	        rLCDSADDR1=(((UINT32T)frameBuffer4Bit>>22)<<21)|M5D((UINT32T)frameBuffer4Bit>>1);
X	        (*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer4Bit>>22)<<21)|(((unsigned int)frameBuffer4Bit>>1) & 0x1fffff);
N	        rLCDSADDR2=M5D( ((UINT32T)frameBuffer4Bit+(SCR_XSIZE_STN*LCD_YSIZE_STN/2))>>1 );
X	        (*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer4Bit+(((320)*2)*(240)/2))>>1) & 0x1fffff);
N	        rLCDSADDR3=(((SCR_XSIZE_STN-LCD_XSIZE_STN)/4)<<11)|(LCD_XSIZE_STN/4);
X	        (*(volatile unsigned *)0x4d00001c)=(((((320)*2)-(320))/4)<<11)|((320)/4);
N	        rDITHMODE=0x0;
X	        (*(volatile unsigned *)0x4d00004c)=0x0;
N       
N            break;
N
N        case MODE_CSTN_8BIT:
X        case (0x2001):
N    	    frameBuffer8Bit=(UINT32T (*)[SCR_XSIZE_CSTN/4])LCDFRAMEBUFFER;
X    	    frameBuffer8Bit=(unsigned int (*)[((320)*2)/4])0x31000000;
N	        rLCDCON1=(CLKVAL_CSTN<<8)|(MVAL_USED<<7)|(2<<5)|(3<<1)|0;
X	        (*(volatile unsigned *)0x4d000000)=((6)<<8)|((0)<<7)|(2<<5)|(3<<1)|0;
N    	    
N    	    // 8-bit single scan,8bpp CSTN,ENVID=off
N	        rLCDCON2=(0<<24)|(LINEVAL_CSTN<<14)|(0<<6)|(0<<0);
X	        (*(volatile unsigned *)0x4d000004)=(0<<24)|(((240)-1)<<14)|(0<<6)|(0<<0);
N	        rLCDCON3=(WDLY_CSTN<<19)|(HOZVAL_CSTN<<8)|(LINEBLANK_CSTN<<0);
X	        (*(volatile unsigned *)0x4d000008)=((0)<<19)|(((320)*3/8-1)<<8)|((16 &0xff)<<0);
N	        rLCDCON4=(MVAL<<8)|(WLH_CSTN<<0);
X	        (*(volatile unsigned *)0x4d00000c)=((13)<<8)|((0)<<0);
N	        rLCDCON5=0;
X	        (*(volatile unsigned *)0x4d000010)=0;
N	       
N            rLCDSADDR1=(((UINT32T)frameBuffer8Bit>>22)<<21 )|M5D((UINT32T)frameBuffer8Bit>>1);
X            (*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer8Bit>>22)<<21 )|(((unsigned int)frameBuffer8Bit>>1) & 0x1fffff);
N	        rLCDSADDR2=M5D( ((UINT32T)frameBuffer8Bit+(SCR_XSIZE_CSTN*LCD_YSIZE_CSTN/1))>>1 );
X	        (*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer8Bit+(((320)*2)*(240)/1))>>1) & 0x1fffff);
N	        rLCDSADDR3=(((SCR_XSIZE_CSTN-LCD_XSIZE_CSTN)/2)<<11)|(LCD_XSIZE_CSTN/2);
X	        (*(volatile unsigned *)0x4d00001c)=(((((320)*2)-(320))/2)<<11)|((320)/2);
N	        rDITHMODE=0x0;
X	        (*(volatile unsigned *)0x4d00004c)=0x0;
N	        rREDLUT  =0xfdb96420;
X	        (*(volatile unsigned *)0x4d000020)  =0xfdb96420;
N	        rGREENLUT=0xfdb96420;
X	        (*(volatile unsigned *)0x4d000024)=0xfdb96420;
N	        rBLUELUT =0xfb40;
X	        (*(volatile unsigned *)0x4d000028) =0xfb40;
N       
N            break;
N	
N        case MODE_CSTN_12BIT:
X        case (0x2002):
N    	    frameBuffer12Bit=(UINT32T (*)[SCR_XSIZE_CSTN*3/8])LCDFRAMEBUFFER;
X    	    frameBuffer12Bit=(unsigned int (*)[((320)*2)*3/8])0x31000000;
N    	    rLCDCON1=(CLKVAL_CSTN<<8)|(MVAL_USED<<7)|(2<<5)|(4<<1)|0;
X    	    (*(volatile unsigned *)0x4d000000)=((6)<<8)|((0)<<7)|(2<<5)|(4<<1)|0;
N    	    
N    	    // 8-bit single scan,12bpp CSTN,ENVID=off
N    	    rLCDCON2=(0<<24)|(LINEVAL_CSTN<<14)|(0<<6)|0;
X    	    (*(volatile unsigned *)0x4d000004)=(0<<24)|(((240)-1)<<14)|(0<<6)|0;
N    	    rLCDCON3=(WDLY_CSTN<<19)|(HOZVAL_CSTN<<8)|(LINEBLANK_CSTN<<0);
X    	    (*(volatile unsigned *)0x4d000008)=((0)<<19)|(((320)*3/8-1)<<8)|((16 &0xff)<<0);
N    	    rLCDCON4=(MVAL<<8)|(WLH_CSTN<<0);
X    	    (*(volatile unsigned *)0x4d00000c)=((13)<<8)|((0)<<0);
N    	    rLCDCON5=0;
X    	    (*(volatile unsigned *)0x4d000010)=0;
N
N    	    rLCDSADDR1=(((UINT32T)frameBuffer12Bit>>22)<<21)|M5D((UINT32T)frameBuffer12Bit>>1);
X    	    (*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer12Bit>>22)<<21)|(((unsigned int)frameBuffer12Bit>>1) & 0x1fffff);
N    	    rLCDSADDR2=M5D(((UINT32T)frameBuffer12Bit+((SCR_XSIZE_CSTN*3/2)*LCD_YSIZE_CSTN))>>1);
X    	    (*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer12Bit+((((320)*2)*3/2)*(240)))>>1) & 0x1fffff);
N    	    rLCDSADDR3=(((SCR_XSIZE_CSTN-LCD_XSIZE_CSTN)*3/4)<<11)|(LCD_XSIZE_CSTN*3/4);
X    	    (*(volatile unsigned *)0x4d00001c)=(((((320)*2)-(320))*3/4)<<11)|((320)*3/4);
N	        rDITHMODE=0;
X	        (*(volatile unsigned *)0x4d00004c)=0;
N        
N            break;
N
N        case MODE_TFT_8BIT_240320:
X        case (0x4102):
N        	frameBuffer8BitTft240320=(UINT32T (*)[SCR_XSIZE_TFT_240320/4])LCDFRAMEBUFFER;
X        	frameBuffer8BitTft240320=(unsigned int (*)[((240)*2)/4])0x31000000;
N        	rLCDCON1=(CLKVAL_TFT_240320<<8)|(MVAL_USED<<7)|(3<<5)|(11<<1)|0;
X        	(*(volatile unsigned *)0x4d000000)=((4)<<8)|((0)<<7)|(3<<5)|(11<<1)|0;
N            
N            // TFT LCD panel,8bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_240320<<24)|(LINEVAL_TFT_240320<<14)|(VFPD_240320<<6)|(VSPW_240320);
X        	(*(volatile unsigned *)0x4d000004)=(((2-1)&0xff)<<24)|(((320)-1)<<14)|(((3-1)&0xff)<<6)|(((2-1) &0x3f));
N        	rLCDCON3=(HBPD_240320<<19)|(HOZVAL_TFT_240320<<8)|(HFPD_240320);
X        	(*(volatile unsigned *)0x4d000008)=(((7-1)&0x7f)<<19)|(((240)-1)<<8)|(((3-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_240320);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((4-1)&0xff));
N        	rLCDCON5=(1<<11)|(1<<9)|(1<<8);                     //FRM5:6:5,HSYNC and VSYNC are inverted
X        	(*(volatile unsigned *)0x4d000010)=(1<<11)|(1<<9)|(1<<8);                     
N        	rLCDSADDR1=(((UINT32T)frameBuffer8BitTft240320>>22)<<21)|M5D((UINT32T)frameBuffer8BitTft240320>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer8BitTft240320>>22)<<21)|(((unsigned int)frameBuffer8BitTft240320>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer8BitTft240320+(SCR_XSIZE_TFT_240320*LCD_YSIZE_TFT_240320/1))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer8BitTft240320+(((240)*2)*(320)/1))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_240320-LCD_XSIZE_TFT_240320)/2)<<11)|(LCD_XSIZE_TFT_240320/2);
X        	(*(volatile unsigned *)0x4d00001c)=(((((240)*2)-(240))/2)<<11)|((240)/2);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N           
N            break;
N    		
N        case MODE_TFT_16BIT_240320:
X        case (0x4104):
N        	frameBuffer16BitTft240320=(UINT32T (*)[SCR_XSIZE_TFT_240320/2])LCDFRAMEBUFFER;
X        	frameBuffer16BitTft240320=(unsigned int (*)[((240)*2)/2])0x31000000;
N        	rLCDCON1=(CLKVAL_TFT_240320<<8)|(MVAL_USED<<7)|(3<<5)|(12<<1)|0;
X        	(*(volatile unsigned *)0x4d000000)=((4)<<8)|((0)<<7)|(3<<5)|(12<<1)|0;
N            
N            // TFT LCD panel,12bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_240320<<24)|(LINEVAL_TFT_240320<<14)|(VFPD_240320<<6)|(VSPW_240320);
X        	(*(volatile unsigned *)0x4d000004)=(((2-1)&0xff)<<24)|(((320)-1)<<14)|(((3-1)&0xff)<<6)|(((2-1) &0x3f));
N        	rLCDCON3=(HBPD_240320<<19)|(HOZVAL_TFT_240320<<8)|(HFPD_240320);
X        	(*(volatile unsigned *)0x4d000008)=(((7-1)&0x7f)<<19)|(((240)-1)<<8)|(((3-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_240320);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((4-1)&0xff));
N        	rLCDCON5=(1<<11)|(1<<9)|(1<<8);                     //FRM5:6:5,HSYNC and VSYNC are inverted
X        	(*(volatile unsigned *)0x4d000010)=(1<<11)|(1<<9)|(1<<8);                     
N        	rLCDSADDR1=(((UINT32T)frameBuffer16BitTft240320>>22)<<21)|M5D((UINT32T)frameBuffer16BitTft240320>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer16BitTft240320>>22)<<21)|(((unsigned int)frameBuffer16BitTft240320>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer16BitTft240320+(SCR_XSIZE_TFT_240320*LCD_YSIZE_TFT_240320*2))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer16BitTft240320+(((240)*2)*(320)*2))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_240320-LCD_XSIZE_TFT_240320)/1)<<11)|(LCD_XSIZE_TFT_240320/1);
X        	(*(volatile unsigned *)0x4d00001c)=(((((240)*2)-(240))/1)<<11)|((240)/1);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N            
N            break;
N
N        case MODE_TFT_1BIT_640480:
X        case (0x4201):
N        	frameBuffer1BitTft640480=(UINT32T (*)[SCR_XSIZE_TFT_640480/32])LCDFRAMEBUFFER;
X        	frameBuffer1BitTft640480=(unsigned int (*)[((640)*2)/32])0x31000000;
N        	rLCDCON1=(CLKVAL_TFT_640480<<8)|(MVAL_USED<<7)|(3<<5)|(8<<1)|0;
X        	(*(volatile unsigned *)0x4d000000)=((1)<<8)|((0)<<7)|(3<<5)|(8<<1)|0;
N        	rLCDCON2=(VBPD_640480<<24)|(LINEVAL_TFT_640480<<14)|(VFPD_640480<<6)|(VSPW_640480);
X        	(*(volatile unsigned *)0x4d000004)=(((33-1)&0xff)<<24)|(((480)-1)<<14)|(((10-1)&0xff)<<6)|(((2-1) &0x3f));
N        	rLCDCON3=(HBPD_640480<<19)|(HOZVAL_TFT_640480<<8)|(HFPD_640480);
X        	(*(volatile unsigned *)0x4d000008)=(((48-1)&0x7f)<<19)|(((640)-1)<<8)|(((16-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_640480);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((96-1)&0xff));
N        	rLCDCON5=(1<<11)|(1<<9)|(1<<8);                     //FRM5:6:5,HSYNC and VSYNC are inverted
X        	(*(volatile unsigned *)0x4d000010)=(1<<11)|(1<<9)|(1<<8);                     
N        	rLCDSADDR1=(((UINT32T)frameBuffer1BitTft640480>>22)<<21)|M5D((UINT32T)frameBuffer1BitTft640480>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer1BitTft640480>>22)<<21)|(((unsigned int)frameBuffer1BitTft640480>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer1BitTft640480+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480/8))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer1BitTft640480+(((640)*2)*(480)/8))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_640480-LCD_XSIZE_TFT_640480)/16)<<11)|(LCD_XSIZE_TFT_640480/16);
X        	(*(volatile unsigned *)0x4d00001c)=(((((640)*2)-(640))/16)<<11)|((640)/16);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N       
N            break;
N    
N        case MODE_TFT_8BIT_640480:
X        case (0x4202):
N        	frameBuffer8BitTft640480=(UINT32T (*)[SCR_XSIZE_TFT_640480/4])LCDFRAMEBUFFER;
X        	frameBuffer8BitTft640480=(unsigned int (*)[((640)*2)/4])0x31000000;
N        	rLCDCON1=(CLKVAL_TFT_640480<<8)|(MVAL_USED<<7)|(3<<5)|(11<<1)|0;
X        	(*(volatile unsigned *)0x4d000000)=((1)<<8)|((0)<<7)|(3<<5)|(11<<1)|0;
N           	
N           	// TFT LCD panel,8bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_640480<<24)|(LINEVAL_TFT_640480<<14)|(VFPD_640480<<6)|(VSPW_640480);
X        	(*(volatile unsigned *)0x4d000004)=(((33-1)&0xff)<<24)|(((480)-1)<<14)|(((10-1)&0xff)<<6)|(((2-1) &0x3f));
N        	rLCDCON3=(HBPD_640480<<19)|(HOZVAL_TFT_640480<<8)|(HFPD_640480);
X        	(*(volatile unsigned *)0x4d000008)=(((48-1)&0x7f)<<19)|(((640)-1)<<8)|(((16-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_640480);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((96-1)&0xff));
N        	rLCDCON5=(1<<11)|(1<<9)|(1<<8);                     //FRM5:6:5,HSYNC and VSYNC are inverted
X        	(*(volatile unsigned *)0x4d000010)=(1<<11)|(1<<9)|(1<<8);                     
N        	rLCDSADDR1=(((UINT32T)frameBuffer8BitTft640480>>22)<<21)|M5D((UINT32T)frameBuffer8BitTft640480>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer8BitTft640480>>22)<<21)|(((unsigned int)frameBuffer8BitTft640480>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer8BitTft640480+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480/1))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer8BitTft640480+(((640)*2)*(480)/1))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_640480-LCD_XSIZE_TFT_640480)/2)<<11)|(LCD_XSIZE_TFT_640480/2);
X        	(*(volatile unsigned *)0x4d00001c)=(((((640)*2)-(640))/2)<<11)|((640)/2);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N       
N            break;
N        	
N        case MODE_TFT_16BIT_640480:
X        case (0x4204):
N            frameBuffer16BitTft640480=(UINT32T (*)[SCR_XSIZE_TFT_640480/2])LCDFRAMEBUFFER;
X            frameBuffer16BitTft640480=(unsigned int (*)[((640)*2)/2])0x31000000;
N        	rLCDCON1=(CLKVAL_TFT_640480<<8)|(MVAL_USED<<7)|(3<<5)|(12<<1)|0;
X        	(*(volatile unsigned *)0x4d000000)=((1)<<8)|((0)<<7)|(3<<5)|(12<<1)|0;
N            
N            // TFT LCD panel,16bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_640480<<24)|(LINEVAL_TFT_640480<<14)|(VFPD_640480<<6)|(VSPW_640480);
X        	(*(volatile unsigned *)0x4d000004)=(((33-1)&0xff)<<24)|(((480)-1)<<14)|(((10-1)&0xff)<<6)|(((2-1) &0x3f));
N        	rLCDCON3=(HBPD_640480<<19)|(HOZVAL_TFT_640480<<8)|(HFPD_640480);
X        	(*(volatile unsigned *)0x4d000008)=(((48-1)&0x7f)<<19)|(((640)-1)<<8)|(((16-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_640480);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((96-1)&0xff));
N        	rLCDCON5=(1<<11)|(1<<9)|(1<<8);                 	//FRM5:6:5,HSYNC and VSYNC are inverted
X        	(*(volatile unsigned *)0x4d000010)=(1<<11)|(1<<9)|(1<<8);                 	
N        	rLCDSADDR1=(((UINT32T)frameBuffer16BitTft640480>>22)<<21)|M5D((UINT32T)frameBuffer16BitTft640480>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer16BitTft640480>>22)<<21)|(((unsigned int)frameBuffer16BitTft640480>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer16BitTft640480+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480*2))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer16BitTft640480+(((640)*2)*(480)*2))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_640480-LCD_XSIZE_TFT_640480)/1)<<11)|(LCD_XSIZE_TFT_640480/1);
X        	(*(volatile unsigned *)0x4d00001c)=(((((640)*2)-(640))/1)<<11)|((640)/1);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N       
N            break;
N        
N        case MODE_TFT_16BIT_800480:
X        case (0x4208):
N            frameBuffer16BitTft800480=(UINT32T (*)[SCR_XSIZE_TFT_800480/2])LCDFRAMEBUFFER;
X            frameBuffer16BitTft800480=(unsigned int (*)[((800)*2)/2])0x31000000;
N        	rLCDCON1=(CLKVAL_TFT_800480<<8)|(MVAL_USED<<7)|(3<<5)|(12<<1)|0;
X        	(*(volatile unsigned *)0x4d000000)=((0)<<8)|((0)<<7)|(3<<5)|(12<<1)|0;
N            
N            // TFT LCD panel,16bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_800480<<24)|(LINEVAL_TFT_800480<<14)|(VFPD_800480<<6)|(VSPW_800480);
X        	(*(volatile unsigned *)0x4d000004)=(((15)&0xff)<<24)|(((480)-1)<<14)|(((15)&0xff)<<6)|(((30) &0x3f));
N        	rLCDCON3=(HBPD_800480<<19)|(HOZVAL_TFT_800480<<8)|(HFPD_800480);
X        	(*(volatile unsigned *)0x4d000008)=(((30)&0x7f)<<19)|(((800)-1)<<8)|(((70)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_800480);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((100)&0xff));
N        	rLCDCON5=(1<<11)|(1<<9)|(1<<8);                 	//FRM5:6:5,HSYNC and VSYNC are inverted
X        	(*(volatile unsigned *)0x4d000010)=(1<<11)|(1<<9)|(1<<8);                 	
N        	rLCDSADDR1=(((UINT32T)frameBuffer16BitTft800480>>22)<<21)|M5D((UINT32T)frameBuffer16BitTft800480>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer16BitTft800480>>22)<<21)|(((unsigned int)frameBuffer16BitTft800480>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer16BitTft800480+(SCR_XSIZE_TFT_800480*LCD_YSIZE_TFT_800480*2))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer16BitTft800480+(((800)*2)*(480)*2))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_800480-LCD_XSIZE_TFT_800480)/1)<<11)|(LCD_XSIZE_TFT_800480/1);
X        	(*(volatile unsigned *)0x4d00001c)=(((((800)*2)-(800))/1)<<11)|((800)/1);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N       
N            break;
N
N        case MODE_TFT_24BIT_640480:
X        case (0x42016):
N            frameBuffer24BitTft640480=(UINT32T (*)[SCR_XSIZE_TFT_640480])LCDFRAMEBUFFER;
X            frameBuffer24BitTft640480=(unsigned int (*)[((640)*2)])0x31000000;
N            rLCDCON1=(CLKVAL_TFT_640480<<8)|(MVAL_USED<<7)|(3<<5)|(13<<1)|0;
X            (*(volatile unsigned *)0x4d000000)=((1)<<8)|((0)<<7)|(3<<5)|(13<<1)|0;
N                
N            // TFT LCD panel,24bpp TFT,ENVID=off
N            rLCDCON2=(VBPD_640480<<24)|(LINEVAL_TFT_640480<<14)|(VFPD_640480<<6)|(VSPW_640480);
X            (*(volatile unsigned *)0x4d000004)=(((33-1)&0xff)<<24)|(((480)-1)<<14)|(((10-1)&0xff)<<6)|(((2-1) &0x3f));
N            rLCDCON3=(HBPD_640480<<19)|(HOZVAL_TFT_640480<<8)|(HFPD_640480);
X            (*(volatile unsigned *)0x4d000008)=(((48-1)&0x7f)<<19)|(((640)-1)<<8)|(((16-1)&0xff));
N            rLCDCON4=(MVAL<<8)|(HSPW_640480);
X            (*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((96-1)&0xff));
N            rLCDCON5=(1<<12)|(1<<9)|(1<<8);                     // BPP24:MSB,HSYNC and VSYNC are inverted
X            (*(volatile unsigned *)0x4d000010)=(1<<12)|(1<<9)|(1<<8);                     
N            rLCDSADDR1=(((UINT32T)frameBuffer24BitTft640480>>22)<<21)|M5D((UINT32T)frameBuffer24BitTft640480>>1);
X            (*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer24BitTft640480>>22)<<21)|(((unsigned int)frameBuffer24BitTft640480>>1) & 0x1fffff);
N            rLCDSADDR2=M5D( ((UINT32T)frameBuffer24BitTft640480+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480*4))>>1 );
X            (*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer24BitTft640480+(((640)*2)*(480)*4))>>1) & 0x1fffff);
N            rLCDSADDR3=(((SCR_XSIZE_TFT_640480-LCD_XSIZE_TFT_640480)*2)<<11)|(LCD_XSIZE_TFT_640480*2);
X            (*(volatile unsigned *)0x4d00001c)=(((((640)*2)-(640))*2)<<11)|((640)*2);
N            rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X            (*(volatile unsigned *)0x4d00005c)|=(3);                                    
N            rLPCSEL&=(~7);                                      // Disable LPC3600
X            (*(volatile unsigned *)0x4d000060)&=(~7);                                      
N            rTPAL=0;                                            // Disable Temp Palette
X            (*(volatile unsigned *)0x4d000050)=0;                                            
N            
N            break;
N        
N        case MODE_TFT_1BIT_800600:
X        case (0x4401):
N        	frameBuffer1BitTft800600=(UINT32T (*)[SCR_XSIZE_TFT_800600/32])LCDFRAMEBUFFER;
X        	frameBuffer1BitTft800600=(unsigned int (*)[((800)*2)/32])0x31000000;
N           	rLCDCON1=(CLKVAL_TFT_800600<<8)|(MVAL_USED<<7)|(3<<5)|(8<<1)|0;
X           	(*(volatile unsigned *)0x4d000000)=((0)<<8)|((0)<<7)|(3<<5)|(8<<1)|0;
N
N            // TFT LCD panel,1bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_800600<<24)|(LINEVAL_TFT_800600<<14)|(VFPD_800600<<6)|(VSPW_800600);
X        	(*(volatile unsigned *)0x4d000004)=(((2-1)&0xff)<<24)|(((600)-1)<<14)|(((3-1)&0xff)<<6)|(((1-1) &0x3f));
N        	rLCDCON3=(HBPD_800600<<19)|(HOZVAL_TFT_800600<<8)|(HFPD_800600);
X        	(*(volatile unsigned *)0x4d000008)=(((30-1)&0x7f)<<19)|(((800)-1)<<8)|(((30-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_800600);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((12-1)&0xff));
N        	rLCDCON5=(1<<9)|(1<<8);	
X        	(*(volatile unsigned *)0x4d000010)=(1<<9)|(1<<8);	
N
N        	rLCDSADDR1=(((UINT32T)frameBuffer1BitTft800600>>22)<<21)|M5D((UINT32T)frameBuffer1BitTft800600>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer1BitTft800600>>22)<<21)|(((unsigned int)frameBuffer1BitTft800600>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer1BitTft800600+(SCR_XSIZE_TFT_800600*LCD_YSIZE_TFT_800600/8))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer1BitTft800600+(((800)*2)*(600)/8))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_800600-LCD_XSIZE_TFT_800600)/16)<<11)|(LCD_XSIZE_TFT_800600/16);
X        	(*(volatile unsigned *)0x4d00001c)=(((((800)*2)-(800))/16)<<11)|((800)/16);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N        
N            break;
N    
N        case MODE_TFT_8BIT_800600:
X        case (0x4402):
N        	frameBuffer8BitTft800600=(UINT32T (*)[SCR_XSIZE_TFT_800600/4])LCDFRAMEBUFFER;
X        	frameBuffer8BitTft800600=(unsigned int (*)[((800)*2)/4])0x31000000;
N           	rLCDCON1=(CLKVAL_TFT_800600<<8)|(MVAL_USED<<7)|(3<<5)|(11<<1)|0;
X           	(*(volatile unsigned *)0x4d000000)=((0)<<8)|((0)<<7)|(3<<5)|(11<<1)|0;
N            
N            // TFT LCD panel,8bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_800600<<24)|(LINEVAL_TFT_800600<<14)|(VFPD_800600<<6)|(VSPW_800600);
X        	(*(volatile unsigned *)0x4d000004)=(((2-1)&0xff)<<24)|(((600)-1)<<14)|(((3-1)&0xff)<<6)|(((1-1) &0x3f));
N        	rLCDCON3=(HBPD_800600<<19)|(HOZVAL_TFT_800600<<8)|(HFPD_800600);
X        	(*(volatile unsigned *)0x4d000008)=(((30-1)&0x7f)<<19)|(((800)-1)<<8)|(((30-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_800600);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((12-1)&0xff));
N        	rLCDCON5=(1<<9)|(1<<8);	
X        	(*(volatile unsigned *)0x4d000010)=(1<<9)|(1<<8);	
N
N        	rLCDSADDR1=(((UINT32T)frameBuffer8BitTft800600>>22)<<21)|M5D((UINT32T)frameBuffer8BitTft800600>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer8BitTft800600>>22)<<21)|(((unsigned int)frameBuffer8BitTft800600>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer8BitTft800600+(SCR_XSIZE_TFT_800600*LCD_YSIZE_TFT_800600/1))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer8BitTft800600+(((800)*2)*(600)/1))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_800600-LCD_XSIZE_TFT_800600)/2)<<11)|(LCD_XSIZE_TFT_800600/2);
X        	(*(volatile unsigned *)0x4d00001c)=(((((800)*2)-(800))/2)<<11)|((800)/2);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N       
N            break;
N        	
N        case MODE_TFT_16BIT_800600:
X        case (0x4404):
N        	frameBuffer16BitTft800600=(UINT32T (*)[SCR_XSIZE_TFT_800600/2])LCDFRAMEBUFFER;
X        	frameBuffer16BitTft800600=(unsigned int (*)[((800)*2)/2])0x31000000;
N           	rLCDCON1=(CLKVAL_TFT_800600<<8)|(MVAL_USED<<7)|(3<<5)|(12<<1)|0;
X           	(*(volatile unsigned *)0x4d000000)=((0)<<8)|((0)<<7)|(3<<5)|(12<<1)|0;
N            
N            // TFT LCD panel,16bpp TFT,ENVID=off
N        	rLCDCON2=(VBPD_800600<<24)|(LINEVAL_TFT_800600<<14)|(VFPD_800600<<6)|(VSPW_800600);
X        	(*(volatile unsigned *)0x4d000004)=(((2-1)&0xff)<<24)|(((600)-1)<<14)|(((3-1)&0xff)<<6)|(((1-1) &0x3f));
N        	rLCDCON3=(HBPD_800600<<19)|(HOZVAL_TFT_800600<<8)|(HFPD_800600);
X        	(*(volatile unsigned *)0x4d000008)=(((30-1)&0x7f)<<19)|(((800)-1)<<8)|(((30-1)&0xff));
N        	rLCDCON4=(MVAL<<8)|(HSPW_800600);
X        	(*(volatile unsigned *)0x4d00000c)=((13)<<8)|(((12-1)&0xff));
N        	rLCDCON5=(1<<11)|(1<<10)|(1<<9)|(1<<8);
X        	(*(volatile unsigned *)0x4d000010)=(1<<11)|(1<<10)|(1<<9)|(1<<8);
N        	
N        	rLCDSADDR1=(((UINT32T)frameBuffer16BitTft800600>>22)<<21)|M5D((UINT32T)frameBuffer16BitTft800600>>1);
X        	(*(volatile unsigned *)0x4d000014)=(((unsigned int)frameBuffer16BitTft800600>>22)<<21)|(((unsigned int)frameBuffer16BitTft800600>>1) & 0x1fffff);
N        	rLCDSADDR2=M5D( ((UINT32T)frameBuffer16BitTft800600+(SCR_XSIZE_TFT_800600*LCD_YSIZE_TFT_800600*2))>>1 );
X        	(*(volatile unsigned *)0x4d000018)=((((unsigned int)frameBuffer16BitTft800600+(((800)*2)*(600)*2))>>1) & 0x1fffff);
N        	rLCDSADDR3=(((SCR_XSIZE_TFT_800600-LCD_XSIZE_TFT_800600)/1)<<11)|(LCD_XSIZE_TFT_800600/1);
X        	(*(volatile unsigned *)0x4d00001c)=(((((800)*2)-(800))/1)<<11)|((800)/1);
N        	rLCDINTMSK|=(3);                                    // MASK LCD Sub Interrupt
X        	(*(volatile unsigned *)0x4d00005c)|=(3);                                    
N        	rLPCSEL&=(~7);                                      // Disable LPC3600
X        	(*(volatile unsigned *)0x4d000060)&=(~7);                                      
N        	rTPAL=0;                                            // Disable Temp Palette
X        	(*(volatile unsigned *)0x4d000050)=0;                                            
N        
N            break;
N    
N        default:
N            break;
N   }	
N}
N
N/*********************************************************************************************
N* name:		Lcd_CstnOnOff
N* func:		lcd cstn onoff configuration 
N* para:		int onoff   --  cstn configuration
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid Lcd_CstnOnOff(int onoff)
N{
N    // 1:CSTN Panel on  0:CSTN Panel off //	
N    if(onoff==1)
N    	rLCDCON1|=1;                                            // ENVID=ON
X    	(*(volatile unsigned *)0x4d000000)|=1;                                            
N    else
N    	rLCDCON1 =rLCDCON1 & 0x3fffe;                           // ENVID Off
X    	(*(volatile unsigned *)0x4d000000) =(*(volatile unsigned *)0x4d000000) & 0x3fffe;                           
N        rGPBUP=rGPBUP|(1<<5);                                   // Pull-up disable
X        (*(volatile unsigned *)0x56000018)=(*(volatile unsigned *)0x56000018)|(1<<5);                                   
N        rGPBDAT=rGPBDAT&(~(1<<5))|(onoff<<5);                   // GPB5=On or Off
X        (*(volatile unsigned *)0x56000014)=(*(volatile unsigned *)0x56000014)&(~(1<<5))|(onoff<<5);                   
N        rGPBCON=rGPBCON&(~(3<<10))|(1<<10);                     // GPD9=output
X        (*(volatile unsigned *)0x56000010)=(*(volatile unsigned *)0x56000010)&(~(3<<10))|(1<<10);                     
N}    
N
N
N/*********************************************************************************************
N* name:		Lcd_EnvidOnOff
N* func:		lcd Envid onoff configuration 
N* para:		int onoff   --  Envid configuration
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid Lcd_EnvidOnOff(int onoff)
N{
N    if(onoff==1)
N    	rLCDCON1|=0x00000001;                                            // ENVID=ON		
X    	(*(volatile unsigned *)0x4d000000)|=0x00000001;                                            
N	else
N    	rLCDCON1 =rLCDCON1 & 0x3fffe;                           // ENVID Off
X    	(*(volatile unsigned *)0x4d000000) =(*(volatile unsigned *)0x4d000000) & 0x3fffe;                           
N}    
N
N
N/*********************************************************************************************
N* name:		Lcd_Lpc3600Enable
N* func:		Enable Lpc3600  
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid Lcd_Lpc3600Enable(void)
N{
N    rLPCSEL&=~(7);
X    (*(volatile unsigned *)0x4d000060)&=~(7);
N    rLPCSEL|=(7);                                               // 240320,Enable LPC3600
X    (*(volatile unsigned *)0x4d000060)|=(7);                                               
N}    
N
N/*********************************************************************************************
N* name:		Lcd_PowerEnable
N* func:		Enable power  
N* para:		int invpwren    --  indicates the PWREN signal polarity.
N*           int pwren       --  LCD_PWREN output signal enable/disable.
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid Lcd_PowerEnable(int invpwren,int pwren)
N{
N    //GPG4 is setted as LCD_PWREN
N    rGPGUP=rGPGUP&(~(1<<4))|(1<<4);                             // Pull-up disable
X    (*(volatile unsigned *)0x56000068)=(*(volatile unsigned *)0x56000068)&(~(1<<4))|(1<<4);                             
N    rGPGCON=rGPGCON&(~(3<<8))|(3<<8);                           // GPG4=LCD_PWREN
X    (*(volatile unsigned *)0x56000060)=(*(volatile unsigned *)0x56000060)&(~(3<<8))|(3<<8);                           
N    
N    //Enable LCD POWER ENABLE Function
N    rLCDCON5=rLCDCON5&(~(1<<3))|(pwren<<3);                     // PWREN
X    (*(volatile unsigned *)0x4d000010)=(*(volatile unsigned *)0x4d000010)&(~(1<<3))|(pwren<<3);                     
N    rLCDCON5=rLCDCON5&(~(1<<5))|(invpwren<<5);                  // INVPWREN
X    (*(volatile unsigned *)0x4d000010)=(*(volatile unsigned *)0x4d000010)&(~(1<<5))|(invpwren<<5);                  
N}    
N
N/*********************************************************************************************
N* name:		MoveViewPort
N* func:		screen scrolling  
N* para:		int type    --  lcd display mode.
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid MoveViewPort(int type)
N{
N    int vx=0,vy=0,vd;
N    vd=(type==MODE_STN_1BIT)*16+(type==MODE_STN_2BIT)*8+(type==MODE_STN_4BIT)*4
X    vd=(type==(0x1001))*16+(type==(0x1002))*8+(type==(0x1004))*4
N        +(type==MODE_CSTN_8BIT)*2+(type==MODE_CSTN_12BIT)*4 
X        +(type==(0x2001))*2+(type==(0x2002))*4 
N        +(type==MODE_TFT_1BIT_240320)*16+(type==MODE_TFT_8BIT_240320)*2+(type==MODE_TFT_16BIT_240320)*1
X        +(type==(0x4101))*16+(type==(0x4102))*2+(type==(0x4104))*1
N        +(type==MODE_TFT_1BIT_640480)*16+(type==MODE_TFT_8BIT_640480)*2+(type==MODE_TFT_16BIT_640480)*1+(type==MODE_TFT_24BIT_640480)/2
X        +(type==(0x4201))*16+(type==(0x4202))*2+(type==(0x4204))*1+(type==(0x42016))/2
N        +(type==MODE_TFT_1BIT_800600)*16+(type==MODE_TFT_8BIT_800600)*2+(type==MODE_TFT_16BIT_800600)*1;        
X        +(type==(0x4401))*16+(type==(0x4402))*2+(type==(0x4404))*1;        
N    while(1)
N    {
N    	switch(uart_getch())
N    	{
N        	case 'i':
N        	    if(vy>=vd)vy-=vd;    	   	
N                break;
N        
N        	case 'j':
N        	    if(vx>=vd)vx-=vd;
N            	break;
N
N    	case 'k':
N    	    //if((type==MODE_TFT_1BIT_800600)|(type==MODE_TFT_8BIT_800600)|(type==MODE_TFT_16BIT_800600))   
N    	    if((type&0x4000)&&(type&0x400))		  
N    	    {
N                if(vx<=(SCR_XSIZE_TFT_800600-LCD_XSIZE_TFT_800600-vd))vx+=vd;   	    
X                if(vx<=(((800)*2)-(800)-vd))vx+=vd;   	    
N    	   }
N    	    //else if((type==MODE_TFT_1BIT_640480)|(type==MODE_TFT_8BIT_640480)|(type==MODE_TFT_16BIT_640480)|(type==MODE_TFT_24BIT_640480))   
N    	    else if((type&0x4000)&&(type&0x200))		  
N    	    {
N                if(vx<=(SCR_XSIZE_TFT_640480-LCD_XSIZE_TFT_640480-vd))vx+=vd;   	    
X                if(vx<=(((640)*2)-(640)-vd))vx+=vd;   	    
N    	   }
N            //else if((type==MODE_TFT_8BIT_240320)|(type==MODE_TFT_16BIT_240320))   
N    	    else if((type&0x4000)&&(type&0x100)) 
N    	    {
N                if(vx<=(SCR_XSIZE_TFT_240320-LCD_XSIZE_TFT_240320-vd))vx+=vd;   	    
X                if(vx<=(((240)*2)-(240)-vd))vx+=vd;   	    
N    	   }
N            //else if((type==MODE_CSTN_8BIT)|(type==MODE_CSTN_12BIT))   
N            else if(type&0x2000)   
N            {
N                if(vx<=(SCR_XSIZE_CSTN-LCD_XSIZE_CSTN-vd))vx+=vd;   	    
X                if(vx<=(((320)*2)-(320)-vd))vx+=vd;   	    
N           }
N            else
N            {
N                if(vx<=(SCR_XSIZE_STN-LCD_XSIZE_STN-vd))vx+=vd;   	    
X                if(vx<=(((320)*2)-(320)-vd))vx+=vd;   	    
N           }
N       	    break;
N
N    	case 'm':
N    	    if((type&0x4000)&&(type&0x400))
N            {
N                if(vy<=(SCR_YSIZE_TFT_800600-LCD_YSIZE_TFT_800600-vd))vy+=vd; 
X                if(vy<=(((600)*2)-(600)-vd))vy+=vd; 
N                else if(vy==592) vy+=8;
N           }
N    	    else if((type&0x4000)&&(type&0x200))
N            {
N                if(vy<=(SCR_YSIZE_TFT_640480-LCD_YSIZE_TFT_640480-vd))vy+=vd;   	    
X                if(vy<=(((480)*2)-(480)-vd))vy+=vd;   	    
N           }
N    	    else if((type&0x4000)&&(type&0x100))
N            {
N                if(vy<=(SCR_YSIZE_TFT_240320-LCD_YSIZE_TFT_240320-vd))vy+=vd;   	    
X                if(vy<=(((320)*2)-(320)-vd))vy+=vd;   	    
N           }
N            else if(type&0x2000)   
N            {
N                if(vy<=(SCR_YSIZE_CSTN-LCD_YSIZE_CSTN-vd))vy+=vd;   	    
X                if(vy<=(((240)*2)-(240)-vd))vy+=vd;   	    
N           }
N            else
N            {
N                if(vy<=(SCR_YSIZE_STN-LCD_YSIZE_STN-vd))vy+=vd;   	    
X                if(vy<=(((240)*2)-(240)-vd))vy+=vd;   	    
N           }
N            
N       	    break;
N
N    	case '\r':
N       	    return;
N
N    	default:
N    	    break;
N		}
N    	uart_printf("vx=%3d,vy=%3d\n",vx,vy);
N    	Lcd_MoveViewPort(vx,vy,type);
N   }
N}
N
N/*********************************************************************************************
N* name:		Lcd_MoveViewPort
N* func:		screen scrolling  
N* para:		int vx      --  horizontal pixel to move
N*           int vy      --  vertical pixel to move
N*           int type    --  lcd display mode.
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N
Nvoid Lcd_MoveViewPort(int vx,int vy,int type)
N{
N    UINT32T addr;
X    unsigned int addr;
N    switch(type)
N    {
N        case MODE_STN_1BIT:
X        case (0x1001):
N        	// LCDBASEU,LCDBASEL register has to be changed before 12 words before the end of VLINE.
N        	// In mono mode, x=320 is 10 words, So, We can't change LCDBASEU,LCDBASEL 
N        	// during LINECNT=1~0 at mono mode. 
N            // The processor mode should be superviser mode.  
N        //	SET_IF();
N        	#if (LCD_XSIZE_STN<512)
X        	#if ((320)<512)
N        	    while((rLCDCON1>>18)<=1);                       // if x<512
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)<=1);                       
N           	#else	
S        	    while((rLCDCON1>>18)==0);                       // if x>512 ((12+4)*32) 
N        	#endif
N        	addr=(UINT32T)frameBuffer1Bit+(vx/8)+vy*(SCR_XSIZE_STN/8);
X        	addr=(unsigned int)frameBuffer1Bit+(vx/8)+vy*(((320)*2)/8);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D( ((addr+(SCR_XSIZE_STN*LCD_YSIZE_STN/8))>>1) );
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((320)*2)*(240)/8))>>1)) & 0x1fffff);
N        //	CLR_IF();
N           	break;
N
N        case MODE_STN_2BIT:
X        case (0x1002):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_STN<256)
X        	#if ((320)<256)
S           	    while((rLCDCON1>>18)<=1);                       // if x<256
N        	#else	
N                while((rLCDCON1>>18)==0);                       // if x>256
X                while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer2Bit+(vx/4)+vy*(SCR_XSIZE_STN/4);
X            addr=(unsigned int)frameBuffer2Bit+(vx/4)+vy*(((320)*2)/4);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_STN*LCD_YSIZE_STN/4))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((320)*2)*(240)/4))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_STN_4BIT:
X        case (0x1004):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_STN<128)
X        	#if ((320)<128)
S        	    while((rLCDCON1>>18)<=1);                       // if x<128
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>128
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer4Bit+(vx/2)+vy*(SCR_XSIZE_STN/2);
X            addr=(unsigned int)frameBuffer4Bit+(vx/2)+vy*(((320)*2)/2);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_STN*LCD_YSIZE_STN/2))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((320)*2)*(240)/2))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_CSTN_8BIT:
X        case (0x2001):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_CSTN<64)
X        	#if ((320)<64)
S        	    while((rLCDCON1>>18)<=1);                       // if x<64
N        	#else	
N         	    while((rLCDCON1>>18)==0);                       // if x>64
X         	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer8Bit+(vx/1)+vy*(SCR_XSIZE_CSTN/1);
X            addr=(unsigned int)frameBuffer8Bit+(vx/1)+vy*(((320)*2)/1);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_CSTN*LCD_YSIZE_CSTN))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((320)*2)*(240)))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_CSTN_12BIT:
X        case (0x2002):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_CSTN<43)
X        	#if ((320)<43)
S        	    while((rLCDCON1>>18)<=1);                       // if x<43
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>43
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N        	
N        	// Move 6Byte(4pixel)
N        	addr=(UINT32T)frameBuffer12Bit+(vx*3/2)+vy*(SCR_XSIZE_CSTN*3/2); 
X        	addr=(unsigned int)frameBuffer12Bit+(vx*3/2)+vy*(((320)*2)*3/2); 
N        	
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_CSTN*LCD_YSIZE_CSTN*3/2))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((320)*2)*(240)*3/2))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N    	
N        case MODE_TFT_1BIT_240320:
X        case (0x4101):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_TFT_240320<512)
X        	#if ((240)<512)
N        	    while((rLCDCON1>>18)<=1);                       // if x<512
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)<=1);                       
N        	#else	
S    	    while((rLCDCON1>>18)==0);                           // if x>512
N        	#endif
N            addr=(UINT32T)frameBuffer8BitTft240320+(vx/8)+vy*(SCR_XSIZE_TFT_240320/8);
X            addr=(unsigned int)frameBuffer8BitTft240320+(vx/8)+vy*(((240)*2)/8);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_240320*LCD_YSIZE_TFT_240320/8))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((240)*2)*(320)/8))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_8BIT_240320:
X        case (0x4102):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_TFT_240320<64)
X        	#if ((240)<64)
S        	    while((rLCDCON1>>18)<=1);                       // if x<64
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>64
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer8BitTft240320+(vx/1)+vy*(SCR_XSIZE_TFT_240320/1);
X            addr=(unsigned int)frameBuffer8BitTft240320+(vx/1)+vy*(((240)*2)/1);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_240320*LCD_YSIZE_TFT_240320))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((240)*2)*(320)))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_16BIT_240320:
X        case (0x4104):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_TFT_240320<32)
X        	#if ((240)<32)
S        	    while((rLCDCON1>>18)<=1);                       // if x<32
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>32
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer16BitTft240320+(vx*2)+vy*(SCR_XSIZE_TFT_240320*2);
X            addr=(unsigned int)frameBuffer16BitTft240320+(vx*2)+vy*(((240)*2)*2);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_240320*LCD_YSIZE_TFT_240320*2))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((240)*2)*(320)*2))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_1BIT_640480:
X        case (0x4201):
N        //	SET_IF();
N        	#if (LCD_XSIZE_TFT_640480<512)
X        	#if ((640)<512)
S        	    while((rLCDCON1>>18)<=1);                       // if x<512
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>512 ((12+4)*32) 
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer1BitTft640480+(vx/8)+vy*(SCR_XSIZE_TFT_640480/8);
X            addr=(unsigned int)frameBuffer1BitTft640480+(vx/8)+vy*(((640)*2)/8);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D( ((addr+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480/8))>>1) );
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((640)*2)*(480)/8))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_8BIT_640480:
X        case (0x4202):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_TFT_640480<64)
X        	#if ((640)<64)
S        	    while((rLCDCON1>>18)<=1);                       // if x<64
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>64
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer8BitTft640480+(vx/1)+vy*(SCR_XSIZE_TFT_640480/1);
X            addr=(unsigned int)frameBuffer8BitTft640480+(vx/1)+vy*(((640)*2)/1);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((640)*2)*(480)))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_16BIT_640480:
X        case (0x4204):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_TFT_640480<32)
X        	#if ((640)<32)
S        	    while((rLCDCON1>>18)<=1);                       // if x<32
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>32
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer16BitTft640480+(vx*2)+vy*(SCR_XSIZE_TFT_640480*2);
X            addr=(unsigned int)frameBuffer16BitTft640480+(vx*2)+vy*(((640)*2)*2);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480*2))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((640)*2)*(480)*2))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_24BIT_640480:
X        case (0x42016):
N        //	SET_IF(); 
N        	#if (LCD_XSIZE_TFT_640480<16)
X        	#if ((640)<16)
S        	    while((rLCDCON1>>18)<=1);                       // if x<16
N        	#else	
N        	    while((rLCDCON1>>18)==0);                       // if x>16
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer24BitTft640480+(vx*4)+vy*(SCR_XSIZE_TFT_640480*4);
X            addr=(unsigned int)frameBuffer24BitTft640480+(vx*4)+vy*(((640)*2)*4);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_640480*LCD_YSIZE_TFT_640480*4))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((640)*2)*(480)*4))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_1BIT_800600:
X        case (0x4401):
N        //	SET_IF();
N        	#if (LCD_XSIZE_TFT_800600<512)
X        	#if ((800)<512)
S                while((rLCDCON1>>18)<=1);                       // if x<512
N        	#else	
N                while((rLCDCON1>>18)==0);                       // if x>512 ((12+4)*32) 
X                while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N        	#endif
N            addr=(UINT32T)frameBuffer1BitTft800600+(vx/8)+vy*(SCR_XSIZE_TFT_800600/8);
X            addr=(unsigned int)frameBuffer1BitTft800600+(vx/8)+vy*(((800)*2)/8);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D( ((addr+(SCR_XSIZE_TFT_800600*LCD_YSIZE_TFT_800600/8))>>1) );
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((800)*2)*(600)/8))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_8BIT_800600:
X        case (0x4402):
N        //	SET_IF(); 
N    	    #if (LCD_XSIZE_TFT_800600<64)
X    	    #if ((800)<64)
S        	    while((rLCDCON1>>18)<=1);                       // if x<64
N    	    #else	
N    	        while((rLCDCON1>>18)==0);                       // if x>64
X    	        while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N    	    #endif
N            addr=(UINT32T)frameBuffer8BitTft800600+(vx/1)+vy*(SCR_XSIZE_TFT_800600/1);
X            addr=(unsigned int)frameBuffer8BitTft800600+(vx/1)+vy*(((800)*2)/1);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_800600*LCD_YSIZE_TFT_800600))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((800)*2)*(600)))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        case MODE_TFT_16BIT_800600:
X        case (0x4404):
N        //	SET_IF(); 
N    	    #if (LCD_XSIZE_TFT_800600<32)
X    	    #if ((800)<32)
S        	    while((rLCDCON1>>18)<=1);                       // if x<32
N    	    #else	
N        	    while((rLCDCON1>>18)==0);                       // if x>32
X        	    while(((*(volatile unsigned *)0x4d000000)>>18)==0);                       
N    	    #endif
N            addr=(UINT32T)frameBuffer16BitTft800600+(vx*2)+vy*(SCR_XSIZE_TFT_800600*2);
X            addr=(unsigned int)frameBuffer16BitTft800600+(vx*2)+vy*(((800)*2)*2);
N        	rLCDSADDR1= ( (addr>>22)<<21 ) | M5D(addr>>1);
X        	(*(volatile unsigned *)0x4d000014)= ( (addr>>22)<<21 ) | ((addr>>1) & 0x1fffff);
N        	rLCDSADDR2= M5D(((addr+(SCR_XSIZE_TFT_800600*LCD_YSIZE_TFT_800600*2))>>1));
X        	(*(volatile unsigned *)0x4d000018)= ((((addr+(((800)*2)*(600)*2))>>1)) & 0x1fffff);
N        //	CLR_IF();
N            break;
N
N        default:
N            break;
N   }   
N}    
N    
