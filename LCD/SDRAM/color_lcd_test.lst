L 1 "Source\color_lcd_test.c"
N/*********************************************************************************************
N* File£º	lcdapp.c
N* Author:	Embest	
N* Desc£º	LCD_Test
N* History:	
N*********************************************************************************************/
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								include files						 				    */
N/*------------------------------------------------------------------------------------------*/
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030024
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 12 "Source\color_lcd_test.c" 2
N#include "2410lib.h"
L 1 "..\Common\Inc\2410lib.h" 1
N/*********************************************************************************************
N* File name	: 2410lib.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*********************************************************************************************/
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								include files						 				    */
N/*------------------------------------------------------------------------------------------*/
N#include "def.h"
L 1 "..\Common\Inc\def.h" 1
N/*********************************************************************************************
N* File name	: 2410lib.h
N* Author	: embest
N* Descript	: S3C2410 Example 
N* History
N*********************************************************************************************/
N#ifndef __DEF_H__
N#define __DEF_H__
N
N#define UINT32T unsigned int
N#define INT32T	int
N#define UINT16T unsigned short
N#define INT16T	short int
N#define UINT8T  unsigned char
N#define	INT8T  char
N
N#define TRUE 	1
N#define FALSE 	0
N#define OK		1
N#define FAIL	0
N#define FileEnd	1
N#define	NotEnd	0
N
N#define False 0
N#define True !False
N
N// Sets the result on bPort 
N#define BIT_SET(bPort,bBitMask)        (bPort |= bBitMask)
N#define BIT_CLR(bPort,bBitMask)        (bPort &= ~bBitMask)
N
N// Returns the result
N#define GET_BIT_SET(bPort,bBitMask)    (bPort | bBitMask)
N#define GET_BIT_CLR(bPort,bBitMask)    (bPort & ~bBitMask)
N
N// Returns 0 if the condition is False & a non-zero value if it is True
N#define TEST_BIT_SET(bPort,bBitMask)   (bPort & bBitMask)
N#define TEST_BIT_CLR(bPort,bBitMask)   ((~bPort) & bBitMask)
N
N#endif /*__DEF_H__*/
N
L 12 "..\Common\Inc\2410lib.h" 2
N#include "memcfg.h"
L 1 "..\Common\Inc\memcfg.h" 1
N//************************************************ 
N// NAME    : memcfg.inc
N// DESC	  : Memory bank configuration file
N// Revision: 02.28.2002 ver 0.0
N//************************************************
N
N//Memory Area
N//GCS6 16bit(16MB) SDRAM(0x0c000000-0x0cffffff)
N//GCS7 16bit(16MB) SDRAM(0x0d000000-0x0dffffff)
N//          or
N//GCS6 32bit(32MB) SDRAM(0x0c000000-0x0dffffff)
N
N#ifndef __MEMCFG_H
N#define __MEMCFG_H
N 
N// BUSWIDTH : 16,32
N#define BUSWIDTH    (32)
N
N//64MB
N// 0x30000000 ~ 0x30ffffff : Download Area (16MB) Cacheable
N// 0x31000000 ~ 0x33feffff : Non-Cacheable Area
N// 0x33ff0000 ~ 0x33ff47ff : Heap & RW Area
N// 0x33ff4800 ~ 0x33ff7fff : FIQ ~ User Stack Area
N// 0x33ff8000 ~ 0x33fffeff : Not Used Area
N// 0x33ffff00 ~ 0x33ffffff : Exception & ISR Vector Table
N
N#define _RAM_STARTADDRESS       0x30000000
N#define _NONCACHE_STARTADDRESS	0x31000000
N#define _ISR_STARTADDRESS       0x33ffff00     
N#define _MMUTT_STARTADDRESS     0x33ff8000
N#define _STACK_BASEADDRESS      0x33ff8000
N#define HEAPEND                 0x33ff0000
N
N//BWSCON
N#define DW8			(0x0)
N#define DW16			(0x1)
N#define DW32			(0x2)
N#define WAIT			(0x1<<2)
N#define UBLB			(0x1<<3)
N
N//BUSWIDTH=32
N
N#define B1_BWSCON	 (DW32)
N#define B2_BWSCON	 (DW16)
N#define B3_BWSCON	 (DW16)
N#define B4_BWSCON	 (DW16)
N#define B5_BWSCON	 (DW16)
N#define B6_BWSCON	 (DW32)
N#define B7_BWSCON	 (DW32)
N    
N
N//BANK0CON 
N#define B0_Tacs			0x0	//0clk
N#define B0_Tcos			0x0	//0clk
N#define B0_Tacc			0x7	//14clk
N#define B0_Tcoh			0x0	//0clk
N#define B0_Tah			0x0	//0clk
N#define B0_Tacp			0x0	
N#define B0_PMC			0x0	//normal
N
N//BANK1CON
N#define B1_Tacs			0x0	//0clk
N#define B1_Tcos			0x0	//0clk
N#define B1_Tacc			0x7	//14clk
N#define B1_Tcoh			0x0	//0clk
N#define B1_Tah			0x0	//0clk
N#define B1_Tacp			0x0	
N#define B1_PMC			0x0	//normal
N
N//Bank 2 parameter
N#define B2_Tacs			0x0	//0clk
N#define B2_Tcos			0x0	//0clk
N#define B2_Tacc			0x7	//14clk
N#define B2_Tcoh			0x0	//0clk
N#define B2_Tah			0x0	//0clk
N#define B2_Tacp			0x0	
N#define B2_PMC			0x0	//normal
N
N//Bank 3 parameter
N#define B3_Tacs			0x0	//0clk
N#define B3_Tcos			0x0	//0clk
N#define B3_Tacc			0x7	//14clk
N#define B3_Tcoh			0x0	//0clk
N#define B3_Tah			0x0	//0clk
N#define B3_Tacp			0x0	
N#define B3_PMC			0x0	//normal
N
N//Bank 4 parameter
N#define B4_Tacs			0x0	//0clk
N#define B4_Tcos			0x0	//0clk
N#define B4_Tacc			0x7	//14clk
N#define B4_Tcoh			0x0	//0clk
N#define B4_Tah			0x0	//0clk
N#define B4_Tacp			0x0	
N#define B4_PMC			0x0	//normal
N
N//Bank 5 parameter
N#define B5_Tacs			0x0	//0clk
N#define B5_Tcos			0x0	//0clk
N#define B5_Tacc			0x7	//14clk
N#define B5_Tcoh			0x0	//0clk
N#define B5_Tah			0x0	//0clk
N#define B5_Tacp			0x0	
N#define B5_PMC			0x0	//normal
N
N//Bank 6 parameter
N#define B6_MT			0x3	//SDRAM
N//B6_Trcd			0x0	//2clk
N#define B6_Trcd			0x1	//3clk
N#define B6_SCAN			0x1	//9bit
N
N//Bank 7 parameter
N#define B7_MT			0x3	//SDRAM
N//B7_Trcd			0x0	//2clk
N#define B7_Trcd			0x1	//3clk
N#define B7_SCAN			0x1	//9bit
N
N//REFRESH parameter
N#define REFEN	  	    0x1	//Refresh enable
N#define TREFMD	  	    0x0	//CBR(CAS before RAS)/Auto refresh
N#define Trp	  	        0x0	//2clk
N#define Trc	  	        0x3	//7clk
N		
N#define Tchr			0x2	//3clk
N#define REFCNT			1113	//period=15.6us, HCLK=60Mhz, (2048+1-15.6*60)
N
N
N#endif
N
L 13 "..\Common\Inc\2410lib.h" 2
N#include "option.h"
L 1 "..\Common\Inc\option.h" 1
N/*********************************************************************************************
N* File name	: option.h
N* Author	: embest
N* Descript	: Define S3C2410 CPU Option contents 
N* History
N*********************************************************************************************/
N
N#ifndef __OPTION_H__
N#define __OPTION_H__
N
N#define FCLK 202800000
N#define HCLK (202800000/2)
N#define PCLK (202800000/4)
N#define UCLK PCLK
N
N#ifdef CLK111_50M
S#define FCLK 50000000
S#define HCLK 50000000
S#define PCLK 50000000
S#define UCLK 50000000
N#endif
N
N#ifdef CLK124_135M
S#define FCLK 135428571
S#define HCLK (135428571/2)
S#define PCLK (135428571/4)
N#endif
N
N#ifdef CLK124_200M
S#define FCLK 200000000
S#define HCLK (200000000/2)
S#define PCLK (200000000/4)
N#endif
N
N#ifdef CLK124_220M
S#define FCLK 220000000
S#define HCLK (220000000/2)
S#define PCLK (220000000/4)
N#endif
N
N#ifdef CLK124_226M
S#define FCLK 226000000
S#define HCLK (226000000/2)
S#define PCLK (226000000/4)
N#endif
N
N#ifdef CLK124_237M
S#define FCLK 237000000
S#define HCLK (237000000/2)
S#define PCLK (237000000/4)
S#define UCLK 50000000
N#endif
N
N#define FCLK_SPEED 1
N#if FCLK_SPEED==0   					//  FCLK=203Mhz, Fin=12Mhz for AUDIO     
X#if 1==0   					
S	#define M_MDIV          0xc3
S	#define M_PDIV          0x4
S	#define M_SDIV          0x1
N#elif FCLK_SPEED==1 					// Fin = 12M FCLK = 202.8Mhz M_MDIV = 0xa1 M_PDIV = 0x3 M_SDIV = 0x1
X#elif 1==1 					
N	#define M_MDIV          0xa1
N	#define M_PDIV          0x3
N	#define M_SDIV          0x1
N#endif
N
N#define PWRST             GPIO0
N#define OFFRST            GPIO1
N#define WDRST             GPIO2
N#define POWEROFFLED1	  (0x2<<4)
N#define POWEROFFLED2  	  (0x4<<4)
N#define POWEROFFLED3  	  (0x8<<4)
N
N//USB Device Options
N#define USBDMA		TRUE
N#define USBDMA_DEMAND 	FALSE			// the downloadFileSize should be (64*n)
N#define BULK_PKT_SIZE	32
N
N#endif    //__OPTION_H__	 
N
L 14 "..\Common\Inc\2410lib.h" 2
N#include "register.h"
L 1 "..\Common\Inc\register.h" 1
N/*********************************************************************************************
N* File name	: register.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*********************************************************************************************/
N
N#ifndef _S3C2410_REG_H
N#define _S3C2410_REG_H
N
N#define GPIO(Nb)	(0x00000001 << Nb)
N#define GPIO0		GPIO (0)   // GPIO  [0]	
N#define GPIO1		GPIO (1)   // GPIO  [1]		
N#define GPIO2		GPIO (2)   // GPIO  [2]	
N#define GPIO3		GPIO (3)   // GPIO  [3]	
N#define GPIO4		GPIO (4)   // GPIO  [4]		
N#define GPIO5		GPIO (5)   // GPIO  [5]			
N#define GPIO6		GPIO (6)   // GPIO  [6]			
N#define GPIO7		GPIO (7)   // GPIO  [7]			
N#define GPIO8		GPIO (8)   // GPIO  [8]			
N#define GPIO9		GPIO (9)   // GPIO  [9]			
N#define GPIO10		GPIO (10)  // GPIO [10]				
N#define GPIO11		GPIO (11)  // GPIO [11]			
N#define GPIO12		GPIO (12)  // GPIO [12]			
N#define GPIO13		GPIO (13)  // GPIO [13]				
N#define GPIO14		GPIO (14)  // GPIO [14]			
N#define GPIO15		GPIO (15)  // GPIO [15]			
N#define GPIO16		GPIO (16)  // GPIO [16]				
N#define GPIO17		GPIO (17)  // GPIO [17]			
N
N
N#define INTMSK		0x4A000008
N#define INTPND		0x4A000010
N#define INTSUBMSK	0x4A00001C
N#define WTCON		0x53000000
N#define LOCKTIME	0x4C000000
N#define MPLLCON		0x4C000004
N#define UPLLCON		0x4C000008
N#define CLKDIVN		0x4C000014
N#define BWSCON		0x48000000
N#define REFRESH		0x48000024
N#define BANKSIZE	0x48000028
N#define GPFCON		0x56000050
N#define GPFDAT		0x56000054
N#define GPFUP		0x56000058
N
N#define MISCCR		0x56000080
N#define SCK_NORMAL	(0x7<<17)
N
N#define GSTATUS0	0x560000AC
N#define GSTATUS1	0x560000B0
N#define GSTATUS2	0x560000B4
N#define GSTATUS3	0x560000B8
N#define GSTATUS4	0x560000BC    
N
N#endif
L 15 "..\Common\Inc\2410lib.h" 2
N#include "2410addr.h"
L 1 "..\Common\Inc\2410addr.h" 1
N/*********************************************************************************************
N* File name	: 2410addr.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*			R.X.Huang, Programming modify, March 12, 2005
N*********************************************************************************************/
N
N#ifndef __2410ADDR_H__
N#define __2410ADDR_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "option.h"
N
N// Memory control 
N#define rBWSCON    (*(volatile unsigned *)0x48000000) //Bus width & wait status
N#define rBANKCON0  (*(volatile unsigned *)0x48000004) //Boot ROM control
N#define rBANKCON1  (*(volatile unsigned *)0x48000008) //BANK1 control
N#define rBANKCON2  (*(volatile unsigned *)0x4800000c) //BANK2 cControl
N#define rBANKCON3  (*(volatile unsigned *)0x48000010) //BANK3 control
N#define rBANKCON4  (*(volatile unsigned *)0x48000014) //BANK4 control
N#define rBANKCON5  (*(volatile unsigned *)0x48000018) //BANK5 control
N#define rBANKCON6  (*(volatile unsigned *)0x4800001c) //BANK6 control
N#define rBANKCON7  (*(volatile unsigned *)0x48000020) //BANK7 control
N#define rREFRESH   (*(volatile unsigned *)0x48000024) //DRAM/SDRAM refresh
N#define rBANKSIZE  (*(volatile unsigned *)0x48000028) //Flexible Bank Size
N#define rMRSRB6    (*(volatile unsigned *)0x4800002c) //Mode register set for SDRAM
N#define rMRSRB7    (*(volatile unsigned *)0x48000030) //Mode register set for SDRAM
N
N
N// USB Host
N
N
N// INTERRUPT
N#define rSRCPND     (*(volatile unsigned *)0x4a000000) //Interrupt request status
N#define rINTMOD     (*(volatile unsigned *)0x4a000004) //Interrupt mode control
N#define rINTMSK     (*(volatile unsigned *)0x4a000008) //Interrupt mask control
N#define rPRIORITY   (*(volatile unsigned *)0x4a00000c) //IRQ priority control
N#define rINTPND     (*(volatile unsigned *)0x4a000010) //Interrupt request status
N#define rINTOFFSET  (*(volatile unsigned *)0x4a000014) //Interruot request source offset
N#define rSUBSRCPND  (*(volatile unsigned *)0x4a000018) //Sub source pending
N#define rINTSUBMSK  (*(volatile unsigned *)0x4a00001c) //Interrupt sub mask
N
N
N// DMA
N#define rDISRC0     (*(volatile unsigned *)0x4b000000) //DMA 0 Initial source
N#define rDISRCC0    (*(volatile unsigned *)0x4b000004) //DMA 0 Initial source control
N#define rDIDST0     (*(volatile unsigned *)0x4b000008) //DMA 0 Initial Destination
N#define rDIDSTC0    (*(volatile unsigned *)0x4b00000c) //DMA 0 Initial Destination control
N#define rDCON0      (*(volatile unsigned *)0x4b000010) //DMA 0 Control
N#define rDSTAT0     (*(volatile unsigned *)0x4b000014) //DMA 0 Status
N#define rDCSRC0     (*(volatile unsigned *)0x4b000018) //DMA 0 Current source
N#define rDCDST0     (*(volatile unsigned *)0x4b00001c) //DMA 0 Current destination
N#define rDMASKTRIG0 (*(volatile unsigned *)0x4b000020) //DMA 0 Mask trigger
N
N#define rDISRC1     (*(volatile unsigned *)0x4b000040) //DMA 1 Initial source
N#define rDISRCC1    (*(volatile unsigned *)0x4b000044) //DMA 1 Initial source control
N#define rDIDST1     (*(volatile unsigned *)0x4b000048) //DMA 1 Initial Destination
N#define rDIDSTC1    (*(volatile unsigned *)0x4b00004c) //DMA 1 Initial Destination control
N#define rDCON1      (*(volatile unsigned *)0x4b000050) //DMA 1 Control
N#define rDSTAT1     (*(volatile unsigned *)0x4b000054) //DMA 1 Status
N#define rDCSRC1     (*(volatile unsigned *)0x4b000058) //DMA 1 Current source
N#define rDCDST1     (*(volatile unsigned *)0x4b00005c) //DMA 1 Current destination
N#define rDMASKTRIG1 (*(volatile unsigned *)0x4b000060) //DMA 1 Mask trigger
N
N#define rDISRC2     (*(volatile unsigned *)0x4b000080) //DMA 2 Initial source
N#define rDISRCC2    (*(volatile unsigned *)0x4b000084) //DMA 2 Initial source control
N#define rDIDST2     (*(volatile unsigned *)0x4b000088) //DMA 2 Initial Destination
N#define rDIDSTC2    (*(volatile unsigned *)0x4b00008c) //DMA 2 Initial Destination control
N#define rDCON2      (*(volatile unsigned *)0x4b000090) //DMA 2 Control
N#define rDSTAT2     (*(volatile unsigned *)0x4b000094) //DMA 2 Status
N#define rDCSRC2     (*(volatile unsigned *)0x4b000098) //DMA 2 Current source
N#define rDCDST2     (*(volatile unsigned *)0x4b00009c) //DMA 2 Current destination
N#define rDMASKTRIG2 (*(volatile unsigned *)0x4b0000a0) //DMA 2 Mask trigger
N
N#define rDISRC3     (*(volatile unsigned *)0x4b0000c0) //DMA 3 Initial source
N#define rDISRCC3    (*(volatile unsigned *)0x4b0000c4) //DMA 3 Initial source control
N#define rDIDST3     (*(volatile unsigned *)0x4b0000c8) //DMA 3 Initial Destination
N#define rDIDSTC3    (*(volatile unsigned *)0x4b0000cc) //DMA 3 Initial Destination control
N#define rDCON3      (*(volatile unsigned *)0x4b0000d0) //DMA 3 Control
N#define rDSTAT3     (*(volatile unsigned *)0x4b0000d4) //DMA 3 Status
N#define rDCSRC3     (*(volatile unsigned *)0x4b0000d8) //DMA 3 Current source
N#define rDCDST3     (*(volatile unsigned *)0x4b0000dc) //DMA 3 Current destination
N#define rDMASKTRIG3 (*(volatile unsigned *)0x4b0000e0) //DMA 3 Mask trigger
N
N
N// CLOCK & POWER MANAGEMENT
N#define rLOCKTIME   (*(volatile unsigned *)0x4c000000) //PLL lock time counter
N#define rMPLLCON    (*(volatile unsigned *)0x4c000004) //MPLL Control
N#define rUPLLCON    (*(volatile unsigned *)0x4c000008) //UPLL Control
N#define rCLKCON     (*(volatile unsigned *)0x4c00000c) //Clock generator control
N#define rCLKSLOW    (*(volatile unsigned *)0x4c000010) //Slow clock control
N#define rCLKDIVN    (*(volatile unsigned *)0x4c000014) //Clock divider control
N
N
N// LCD CONTROLLER
N#define rLCDCON1    (*(volatile unsigned *)0x4d000000) //LCD control 1
N#define rLCDCON2    (*(volatile unsigned *)0x4d000004) //LCD control 2
N#define rLCDCON3    (*(volatile unsigned *)0x4d000008) //LCD control 3
N#define rLCDCON4    (*(volatile unsigned *)0x4d00000c) //LCD control 4
N#define rLCDCON5    (*(volatile unsigned *)0x4d000010) //LCD control 5
N#define rLCDSADDR1  (*(volatile unsigned *)0x4d000014) //STN/TFT Frame buffer start address 1
N#define rLCDSADDR2  (*(volatile unsigned *)0x4d000018) //STN/TFT Frame buffer start address 2
N#define rLCDSADDR3  (*(volatile unsigned *)0x4d00001c) //STN/TFT Virtual screen address set
N#define rREDLUT     (*(volatile unsigned *)0x4d000020) //STN Red lookup table
N#define rGREENLUT   (*(volatile unsigned *)0x4d000024) //STN Green lookup table 
N#define rBLUELUT    (*(volatile unsigned *)0x4d000028) //STN Blue lookup table
N#define rDITHMODE   (*(volatile unsigned *)0x4d00004c) //STN Dithering mode
N#define rTPAL       (*(volatile unsigned *)0x4d000050) //TFT Temporary palette
N#define rLCDINTPND  (*(volatile unsigned *)0x4d000054) //LCD Interrupt pending
N#define rLCDSRCPND  (*(volatile unsigned *)0x4d000058) //LCD Interrupt source
N#define rLCDINTMSK  (*(volatile unsigned *)0x4d00005c) //LCD Interrupt mask
N#define rLPCSEL     (*(volatile unsigned *)0x4d000060) //LPC3600 Control
N#define PALETTE     0x4d000400                         //Palette start address
N
N
N// NAND flash
N#define rNFCONF     (*(volatile unsigned *)0x4e000000)      //NAND Flash configuration
N#define rNFCMD      (*(volatile UINT8T *)0x4e000004)            //NADD Flash command
N#define rNFADDR     (*(volatile UINT8T *)0x4e000008)            //NAND Flash address
N#define rNFDATA     (*(volatile UINT8T *)0x4e00000c)            //NAND Flash data
N#define rNFSTAT     (*(volatile unsigned *)0x4e000010)      //NAND Flash operation status
N#define rNFECC      (*(volatile unsigned *)0x4e000014)      //NAND Flash ECC
N#define rNFECC0     (*(volatile UINT8T  *)0x4e000014)
N#define rNFECC1     (*(volatile UINT8T  *)0x4e000015)
N#define rNFECC2     (*(volatile UINT8T  *)0x4e000016)
N
N// UART
N#define rULCON0     (*(volatile unsigned *)0x50000000) //UART 0 Line control
N#define rUCON0      (*(volatile unsigned *)0x50000004) //UART 0 Control
N#define rUFCON0     (*(volatile unsigned *)0x50000008) //UART 0 FIFO control
N#define rUMCON0     (*(volatile unsigned *)0x5000000c) //UART 0 Modem control
N#define rUTRSTAT0   (*(volatile unsigned *)0x50000010) //UART 0 Tx/Rx status
N#define rUERSTAT0   (*(volatile unsigned *)0x50000014) //UART 0 Rx error status
N#define rUFSTAT0    (*(volatile unsigned *)0x50000018) //UART 0 FIFO status
N#define rUMSTAT0    (*(volatile unsigned *)0x5000001c) //UART 0 Modem status
N#define rUBRDIV0    (*(volatile unsigned *)0x50000028) //UART 0 Baud rate divisor
N
N#define rULCON1     (*(volatile unsigned *)0x50004000) //UART 1 Line control
N#define rUCON1      (*(volatile unsigned *)0x50004004) //UART 1 Control
N#define rUFCON1     (*(volatile unsigned *)0x50004008) //UART 1 FIFO control
N#define rUMCON1     (*(volatile unsigned *)0x5000400c) //UART 1 Modem control
N#define rUTRSTAT1   (*(volatile unsigned *)0x50004010) //UART 1 Tx/Rx status
N#define rUERSTAT1   (*(volatile unsigned *)0x50004014) //UART 1 Rx error status
N#define rUFSTAT1    (*(volatile unsigned *)0x50004018) //UART 1 FIFO status
N#define rUMSTAT1    (*(volatile unsigned *)0x5000401c) //UART 1 Modem status
N#define rUBRDIV1    (*(volatile unsigned *)0x50004028) //UART 1 Baud rate divisor
N
N#define rULCON2     (*(volatile unsigned *)0x50008000) //UART 2 Line control
N#define rUCON2      (*(volatile unsigned *)0x50008004) //UART 2 Control
N#define rUFCON2     (*(volatile unsigned *)0x50008008) //UART 2 FIFO control
N#define rUMCON2     (*(volatile unsigned *)0x5000800c) //UART 2 Modem control
N#define rUTRSTAT2   (*(volatile unsigned *)0x50008010) //UART 2 Tx/Rx status
N#define rUERSTAT2   (*(volatile unsigned *)0x50008014) //UART 2 Rx error status
N#define rUFSTAT2    (*(volatile unsigned *)0x50008018) //UART 2 FIFO status
N#define rUMSTAT2    (*(volatile unsigned *)0x5000801c) //UART 2 Modem status
N#define rUBRDIV2    (*(volatile unsigned *)0x50008028) //UART 2 Baud rate divisor
N
N#ifdef __BIG_ENDIAN
S#define rUTXH0      (*(volatile unsigned char *)0x50000023) //UART 0 Transmission Hold
S#define rURXH0      (*(volatile unsigned char *)0x50000027) //UART 0 Receive buffer
S#define rUTXH1      (*(volatile unsigned char *)0x50004023) //UART 1 Transmission Hold
S#define rURXH1      (*(volatile unsigned char *)0x50004027) //UART 1 Receive buffer
S#define rUTXH2      (*(volatile unsigned char *)0x50008023) //UART 2 Transmission Hold
S#define rURXH2      (*(volatile unsigned char *)0x50008027) //UART 2 Receive buffer
S
S#define WrUTXH0(ch) (*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
S#define RdURXH0()   (*(volatile unsigned char *)0x50000027)
S#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
S#define RdURXH1()   (*(volatile unsigned char *)0x50004027)
S#define WrUTXH2(ch) (*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
S#define RdURXH2()   (*(volatile unsigned char *)0x50008027)
S
S#define UTXH0       (0x50000020+3)  //Byte_access address by DMA
S#define URXH0       (0x50000024+3)
S#define UTXH1       (0x50004020+3)
S#define URXH1       (0x50004024+3)
S#define UTXH2       (0x50008020+3)
S#define URXH2       (0x50008024+3)
S
N#else //Little Endian
N#define rUTXH0 (*(volatile unsigned char *)0x50000020) //UART 0 Transmission Hold
N#define rURXH0 (*(volatile unsigned char *)0x50000024) //UART 0 Receive buffer
N#define rUTXH1 (*(volatile unsigned char *)0x50004020) //UART 1 Transmission Hold
N#define rURXH1 (*(volatile unsigned char *)0x50004024) //UART 1 Receive buffer
N#define rUTXH2 (*(volatile unsigned char *)0x50008020) //UART 2 Transmission Hold
N#define rURXH2 (*(volatile unsigned char *)0x50008024) //UART 2 Receive buffer
N
N#define WrUTXH0(ch) (*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
N#define RdURXH0()   (*(volatile unsigned char *)0x50000024)
N#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
N#define RdURXH1()   (*(volatile unsigned char *)0x50004024)
N#define WrUTXH2(ch) (*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
N#define RdURXH2()   (*(volatile unsigned char *)0x50008024)
N
N#define UTXH0       (0x50000020)    //Byte_access address by DMA
N#define URXH0       (0x50000024)
N#define UTXH1       (0x50004020)
N#define URXH1       (0x50004024)
N#define UTXH2       (0x50008020)
N#define URXH2       (0x50008024)
N#endif
N
N
N// PWM TIMER
N#define rTCFG0  (*(volatile unsigned *)0x51000000) //Timer 0 configuration
N#define rTCFG1  (*(volatile unsigned *)0x51000004) //Timer 1 configuration
N#define rTCON   (*(volatile unsigned *)0x51000008) //Timer control
N#define rTCNTB0 (*(volatile unsigned *)0x5100000c) //Timer count buffer 0
N#define rTCMPB0 (*(volatile unsigned *)0x51000010) //Timer compare buffer 0
N#define rTCNTO0 (*(volatile unsigned *)0x51000014) //Timer count observation 0
N#define rTCNTB1 (*(volatile unsigned *)0x51000018) //Timer count buffer 1
N#define rTCMPB1 (*(volatile unsigned *)0x5100001c) //Timer compare buffer 1
N#define rTCNTO1 (*(volatile unsigned *)0x51000020) //Timer count observation 1
N#define rTCNTB2 (*(volatile unsigned *)0x51000024) //Timer count buffer 2
N#define rTCMPB2 (*(volatile unsigned *)0x51000028) //Timer compare buffer 2
N#define rTCNTO2 (*(volatile unsigned *)0x5100002c) //Timer count observation 2
N#define rTCNTB3 (*(volatile unsigned *)0x51000030) //Timer count buffer 3
N#define rTCMPB3 (*(volatile unsigned *)0x51000034) //Timer compare buffer 3
N#define rTCNTO3 (*(volatile unsigned *)0x51000038) //Timer count observation 3
N#define rTCNTB4 (*(volatile unsigned *)0x5100003c) //Timer count buffer 4
N#define rTCNTO4 (*(volatile unsigned *)0x51000040) //Timer count observation 4
N
N
N// USB DEVICE
N#ifdef __BIG_ENDIAN
S<ERROR IF BIG_ENDIAN>
S#define rFUNC_ADDR_REG     (*(volatile unsigned char *)0x52000143) //Function address
S#define rPWR_REG           (*(volatile unsigned char *)0x52000147) //Power management
S#define rEP_INT_REG        (*(volatile unsigned char *)0x5200014b) //EP Interrupt pending and clear
S#define rUSB_INT_REG       (*(volatile unsigned char *)0x5200015b) //USB Interrupt pending and clear
S#define rEP_INT_EN_REG     (*(volatile unsigned char *)0x5200015f) //Interrupt enable
S#define rUSB_INT_EN_REG    (*(volatile unsigned char *)0x5200016f)
S#define rFRAME_NUM1_REG    (*(volatile unsigned char *)0x52000173) //Frame number lower byte
S#define rFRAME_NUM2_REG    (*(volatile unsigned char *)0x52000177) //Frame number higher byte
S#define rINDEX_REG         (*(volatile unsigned char *)0x5200017b) //Register index
S#define rMAXP_REG          (*(volatile unsigned char *)0x52000183) //Endpoint max packet
S#define rEP0_CSR           (*(volatile unsigned char *)0x52000187) //Endpoint 0 status
S#define rIN_CSR1_REG       (*(volatile unsigned char *)0x52000187) //In endpoint control status
S#define rIN_CSR2_REG       (*(volatile unsigned char *)0x5200018b)
S#define rOUT_CSR1_REG      (*(volatile unsigned char *)0x52000193) //Out endpoint control status
S#define rOUT_CSR2_REG      (*(volatile unsigned char *)0x52000197)
S#define rOUT_FIFO_CNT1_REG (*(volatile unsigned char *)0x5200019b) //Endpoint out write count
S#define rOUT_FIFO_CNT2_REG (*(volatile unsigned char *)0x5200019f)
S#define rEP0_FIFO          (*(volatile unsigned char *)0x520001c3) //Endpoint 0 FIFO
S#define rEP1_FIFO          (*(volatile unsigned char *)0x520001c7) //Endpoint 1 FIFO
S#define rEP2_FIFO          (*(volatile unsigned char *)0x520001cb) //Endpoint 2 FIFO
S#define rEP3_FIFO          (*(volatile unsigned char *)0x520001cf) //Endpoint 3 FIFO
S#define rEP4_FIFO          (*(volatile unsigned char *)0x520001d3) //Endpoint 4 FIFO
S#define rEP1_DMA_CON       (*(volatile unsigned char *)0x52000203) //EP1 DMA interface control
S#define rEP1_DMA_UNIT      (*(volatile unsigned char *)0x52000207) //EP1 DMA Tx unit counter
S#define rEP1_DMA_FIFO      (*(volatile unsigned char *)0x5200020b) //EP1 DMA Tx FIFO counter
S#define rEP1_DMA_TTC_L     (*(volatile unsigned char *)0x5200020f) //EP1 DMA total Tx counter
S#define rEP1_DMA_TTC_M     (*(volatile unsigned char *)0x52000213)
S#define rEP1_DMA_TTC_H     (*(volatile unsigned char *)0x52000217)
S#define rEP2_DMA_CON       (*(volatile unsigned char *)0x5200021b) //EP2 DMA interface control
S#define rEP2_DMA_UNIT      (*(volatile unsigned char *)0x5200021f) //EP2 DMA Tx unit counter
S#define rEP2_DMA_FIFO      (*(volatile unsigned char *)0x52000223) //EP2 DMA Tx FIFO counter
S#define rEP2_DMA_TTC_L     (*(volatile unsigned char *)0x52000227) //EP2 DMA total Tx counter
S#define rEP2_DMA_TTC_M     (*(volatile unsigned char *)0x5200022b)
S#define rEP2_DMA_TTC_H     (*(volatile unsigned char *)0x5200022f)
S#define rEP3_DMA_CON       (*(volatile unsigned char *)0x52000243) //EP3 DMA interface control
S#define rEP3_DMA_UNIT      (*(volatile unsigned char *)0x52000247) //EP3 DMA Tx unit counter
S#define rEP3_DMA_FIFO      (*(volatile unsigned char *)0x5200024b) //EP3 DMA Tx FIFO counter
S#define rEP3_DMA_TTC_L     (*(volatile unsigned char *)0x5200024f) //EP3 DMA total Tx counter
S#define rEP3_DMA_TTC_M     (*(volatile unsigned char *)0x52000253)
S#define rEP3_DMA_TTC_H     (*(volatile unsigned char *)0x52000257)
S#define rEP4_DMA_CON       (*(volatile unsigned char *)0x5200025b) //EP4 DMA interface control
S#define rEP4_DMA_UNIT      (*(volatile unsigned char *)0x5200025f) //EP4 DMA Tx unit counter
S#define rEP4_DMA_FIFO      (*(volatile unsigned char *)0x52000263) //EP4 DMA Tx FIFO counter
S#define rEP4_DMA_TTC_L     (*(volatile unsigned char *)0x52000267) //EP4 DMA total Tx counter
S#define rEP4_DMA_TTC_M     (*(volatile unsigned char *)0x5200026b)
S#define rEP4_DMA_TTC_H     (*(volatile unsigned char *)0x5200026f)
S
N#else  // Little Endian
N#define rFUNC_ADDR_REG     (*(volatile unsigned char *)0x52000140) //Function address
N#define rPWR_REG           (*(volatile unsigned char *)0x52000144) //Power management
N#define rEP_INT_REG        (*(volatile unsigned char *)0x52000148) //EP Interrupt pending and clear
N#define rUSB_INT_REG       (*(volatile unsigned char *)0x52000158) //USB Interrupt pending and clear
N#define rEP_INT_EN_REG     (*(volatile unsigned char *)0x5200015c) //Interrupt enable
N#define rUSB_INT_EN_REG    (*(volatile unsigned char *)0x5200016c)
N#define rFRAME_NUM1_REG    (*(volatile unsigned char *)0x52000170) //Frame number lower byte
N#define rFRAME_NUM2_REG    (*(volatile unsigned char *)0x52000174) //Frame number higher byte
N#define rINDEX_REG         (*(volatile unsigned char *)0x52000178) //Register index
N#define rMAXP_REG          (*(volatile unsigned char *)0x52000180) //Endpoint max packet
N#define rEP0_CSR           (*(volatile unsigned char *)0x52000184) //Endpoint 0 status
N#define rIN_CSR1_REG       (*(volatile unsigned char *)0x52000184) //In endpoint control status
N#define rIN_CSR2_REG       (*(volatile unsigned char *)0x52000188)
N#define rOUT_CSR1_REG      (*(volatile unsigned char *)0x52000190) //Out endpoint control status
N#define rOUT_CSR2_REG      (*(volatile unsigned char *)0x52000194)
N#define rOUT_FIFO_CNT1_REG (*(volatile unsigned char *)0x52000198) //Endpoint out write count
N#define rOUT_FIFO_CNT2_REG (*(volatile unsigned char *)0x5200019c)
N#define rEP0_FIFO          (*(volatile unsigned char *)0x520001c0) //Endpoint 0 FIFO
N#define rEP1_FIFO          (*(volatile unsigned char *)0x520001c4) //Endpoint 1 FIFO
N#define rEP2_FIFO          (*(volatile unsigned char *)0x520001c8) //Endpoint 2 FIFO
N#define rEP3_FIFO          (*(volatile unsigned char *)0x520001cc) //Endpoint 3 FIFO
N#define rEP4_FIFO          (*(volatile unsigned char *)0x520001d0) //Endpoint 4 FIFO
N#define rEP1_DMA_CON       (*(volatile unsigned char *)0x52000200) //EP1 DMA interface control
N#define rEP1_DMA_UNIT      (*(volatile unsigned char *)0x52000204) //EP1 DMA Tx unit counter
N#define rEP1_DMA_FIFO      (*(volatile unsigned char *)0x52000208) //EP1 DMA Tx FIFO counter
N#define rEP1_DMA_TTC_L     (*(volatile unsigned char *)0x5200020c) //EP1 DMA total Tx counter
N#define rEP1_DMA_TTC_M     (*(volatile unsigned char *)0x52000210)
N#define rEP1_DMA_TTC_H     (*(volatile unsigned char *)0x52000214)
N#define rEP2_DMA_CON       (*(volatile unsigned char *)0x52000218) //EP2 DMA interface control
N#define rEP2_DMA_UNIT      (*(volatile unsigned char *)0x5200021c) //EP2 DMA Tx unit counter
N#define rEP2_DMA_FIFO      (*(volatile unsigned char *)0x52000220) //EP2 DMA Tx FIFO counter
N#define rEP2_DMA_TTC_L     (*(volatile unsigned char *)0x52000224) //EP2 DMA total Tx counter
N#define rEP2_DMA_TTC_M     (*(volatile unsigned char *)0x52000228)
N#define rEP2_DMA_TTC_H     (*(volatile unsigned char *)0x5200022c)
N#define rEP3_DMA_CON       (*(volatile unsigned char *)0x52000240) //EP3 DMA interface control
N#define rEP3_DMA_UNIT      (*(volatile unsigned char *)0x52000244) //EP3 DMA Tx unit counter
N#define rEP3_DMA_FIFO      (*(volatile unsigned char *)0x52000248) //EP3 DMA Tx FIFO counter
N#define rEP3_DMA_TTC_L     (*(volatile unsigned char *)0x5200024c) //EP3 DMA total Tx counter
N#define rEP3_DMA_TTC_M     (*(volatile unsigned char *)0x52000250)
N#define rEP3_DMA_TTC_H     (*(volatile unsigned char *)0x52000254)
N#define rEP4_DMA_CON       (*(volatile unsigned char *)0x52000258) //EP4 DMA interface control
N#define rEP4_DMA_UNIT      (*(volatile unsigned char *)0x5200025c) //EP4 DMA Tx unit counter
N#define rEP4_DMA_FIFO      (*(volatile unsigned char *)0x52000260) //EP4 DMA Tx FIFO counter
N#define rEP4_DMA_TTC_L     (*(volatile unsigned char *)0x52000264) //EP4 DMA total Tx counter
N#define rEP4_DMA_TTC_M     (*(volatile unsigned char *)0x52000268)
N#define rEP4_DMA_TTC_H     (*(volatile unsigned char *)0x5200026c)
N#endif   // __BIG_ENDIAN
N
N
N// WATCH DOG TIMER
N#define rWTCON   (*(volatile unsigned *)0x53000000) //Watch-dog timer mode
N#define rWTDAT   (*(volatile unsigned *)0x53000004) //Watch-dog timer data
N#define rWTCNT   (*(volatile unsigned *)0x53000008) //Eatch-dog timer count
N
N
N// IIC
N#define rIICCON  (*(volatile unsigned *)0x54000000) //IIC control
N#define rIICSTAT (*(volatile unsigned *)0x54000004) //IIC status
N#define rIICADD  (*(volatile unsigned *)0x54000008) //IIC address
N#define rIICDS   (*(volatile unsigned *)0x5400000c) //IIC data shift
N
N
N// IIS
N#define rIISCON  (*(volatile unsigned *)0x55000000) //IIS Control
N#define rIISMOD  (*(volatile unsigned *)0x55000004) //IIS Mode
N#define rIISPSR  (*(volatile unsigned *)0x55000008) //IIS Prescaler
N#define rIISFCON (*(volatile unsigned *)0x5500000c) //IIS FIFO control
N
N#ifdef __BIG_ENDIAN
S#define IISFIFO  ((volatile unsigned short *)0x55000012) //IIS FIFO entry
S
N#else //Little Endian
N#define IISFIFO  ((volatile unsigned short *)0x55000010) //IIS FIFO entry
N
N#endif
N
N
N// I/O PORT 
N#define rGPACON    (*(volatile unsigned *)0x56000000) //Port A control
N#define rGPADAT    (*(volatile unsigned *)0x56000004) //Port A data
N                        
N#define rGPBCON    (*(volatile unsigned *)0x56000010) //Port B control
N#define rGPBDAT    (*(volatile unsigned *)0x56000014) //Port B data
N#define rGPBUP     (*(volatile unsigned *)0x56000018) //Pull-up control B
N                        
N#define rGPCCON    (*(volatile unsigned *)0x56000020) //Port C control
N#define rGPCDAT    (*(volatile unsigned *)0x56000024) //Port C data
N#define rGPCUP     (*(volatile unsigned *)0x56000028) //Pull-up control C
N                        
N#define rGPDCON    (*(volatile unsigned *)0x56000030) //Port D control
N#define rGPDDAT    (*(volatile unsigned *)0x56000034) //Port D data
N#define rGPDUP     (*(volatile unsigned *)0x56000038) //Pull-up control D
N                        
N#define rGPECON    (*(volatile unsigned *)0x56000040) //Port E control
N#define rGPEDAT    (*(volatile unsigned *)0x56000044) //Port E data
N#define rGPEUP     (*(volatile unsigned *)0x56000048) //Pull-up control E
N                        
N#define rGPFCON    (*(volatile unsigned *)0x56000050) //Port F control
N#define rGPFDAT    (*(volatile unsigned *)0x56000054) //Port F data
N#define rGPFUP     (*(volatile unsigned *)0x56000058) //Pull-up control F
N                        
N#define rGPGCON    (*(volatile unsigned *)0x56000060) //Port G control
N#define rGPGDAT    (*(volatile unsigned *)0x56000064) //Port G data
N#define rGPGUP     (*(volatile unsigned *)0x56000068) //Pull-up control G
N                        
N#define rGPHCON    (*(volatile unsigned *)0x56000070) //Port H control
N#define rGPHDAT    (*(volatile unsigned *)0x56000074) //Port H data
N#define rGPHUP     (*(volatile unsigned *)0x56000078) //Pull-up control H
N                        
N#define rMISCCR    (*(volatile unsigned *)0x56000080) //Miscellaneous control
N#define rDCLKCON   (*(volatile unsigned *)0x56000084) //DCLK0/1 control
N#define rEXTINT0   (*(volatile unsigned *)0x56000088) //External interrupt control register 0
N#define rEXTINT1   (*(volatile unsigned *)0x5600008c) //External interrupt control register 1
N#define rEXTINT2   (*(volatile unsigned *)0x56000090) //External interrupt control register 2
N#define rEINTFLT0  (*(volatile unsigned *)0x56000094) //Reserved
N#define rEINTFLT1  (*(volatile unsigned *)0x56000098) //Reserved
N#define rEINTFLT2  (*(volatile unsigned *)0x5600009c) //External interrupt filter control register 2
N#define rEINTFLT3  (*(volatile unsigned *)0x560000a0) //External interrupt filter control register 3
N#define rEINTMASK  (*(volatile unsigned *)0x560000a4) //External interrupt mask
N#define rEINTPEND  (*(volatile unsigned *)0x560000a8) //External interrupt pending
N#define rGSTATUS0  (*(volatile unsigned *)0x560000ac) //External pin status
N#define rGSTATUS1  (*(volatile unsigned *)0x560000b0) //Chip ID(0x32410000)
N#define rGSTATUS2  (*(volatile unsigned *)0x560000b4) //Reset type
N#define rGSTATUS3  (*(volatile unsigned *)0x560000b8) //Saved data0(32-bit) before entering POWER_OFF mode 
N#define rGSTATUS4  (*(volatile unsigned *)0x560000bc) //Saved data0(32-bit) before entering POWER_OFF mode 
N
N
N// RTC
N#ifdef __BIG_ENDIAN
S#define rRTCCON    (*(volatile unsigned char *)0x57000043) //RTC control
S#define rTICNT     (*(volatile unsigned char *)0x57000047) //Tick time count
S#define rRTCALM    (*(volatile unsigned char *)0x57000053) //RTC alarm control
S#define rALMSEC    (*(volatile unsigned char *)0x57000057) //Alarm second
S#define rALMMIN    (*(volatile unsigned char *)0x5700005b) //Alarm minute
S#define rALMHOUR   (*(volatile unsigned char *)0x5700005f) //Alarm Hour
S#define rALMDATE   (*(volatile unsigned char *)0x57000063) //Alarm day     <-- May 06, 2002 SOP
S#define rALMMON    (*(volatile unsigned char *)0x57000067) //Alarm month
S#define rALMYEAR   (*(volatile unsigned char *)0x5700006b) //Alarm year
S#define rRTCRST    (*(volatile unsigned char *)0x5700006f) //RTC round reset
S#define rBCDSEC    (*(volatile unsigned char *)0x57000073) //BCD second
S#define rBCDMIN    (*(volatile unsigned char *)0x57000077) //BCD minute
S#define rBCDHOUR   (*(volatile unsigned char *)0x5700007b) //BCD hour
S#define rBCDDATE   (*(volatile unsigned char *)0x5700007f) //BCD day       <-- May 06, 2002 SOP
S#define rBCDDAY    (*(volatile unsigned char *)0x57000083) //BCD date      <-- May 06, 2002 SOP
S#define rBCDMON    (*(volatile unsigned char *)0x57000087) //BCD month
S#define rBCDYEAR   (*(volatile unsigned char *)0x5700008b) //BCD year
S
N#else //Little Endian
N#define rRTCCON    (*(volatile unsigned char *)0x57000040) //RTC control
N#define rTICNT     (*(volatile unsigned char *)0x57000044) //Tick time count
N#define rRTCALM    (*(volatile unsigned char *)0x57000050) //RTC alarm control
N#define rALMSEC    (*(volatile unsigned char *)0x57000054) //Alarm second
N#define rALMMIN    (*(volatile unsigned char *)0x57000058) //Alarm minute
N#define rALMHOUR   (*(volatile unsigned char *)0x5700005c) //Alarm Hour
N#define rALMDATE   (*(volatile unsigned char *)0x57000060) //Alarm day      <-- May 06, 2002 SOP
N#define rALMMON    (*(volatile unsigned char *)0x57000064) //Alarm month
N#define rALMYEAR   (*(volatile unsigned char *)0x57000068) //Alarm year
N#define rRTCRST    (*(volatile unsigned char *)0x5700006c) //RTC round reset
N#define rBCDSEC    (*(volatile unsigned char *)0x57000070) //BCD second
N#define rBCDMIN    (*(volatile unsigned char *)0x57000074) //BCD minute
N#define rBCDHOUR   (*(volatile unsigned char *)0x57000078) //BCD hour
N#define rBCDDATE   (*(volatile unsigned char *)0x5700007c) //BCD day        <-- May 06, 2002 SOP
N#define rBCDDAY    (*(volatile unsigned char *)0x57000080) //BCD date       <-- May 06, 2002 SOP
N#define rBCDMON    (*(volatile unsigned char *)0x57000084) //BCD month
N#define rBCDYEAR   (*(volatile unsigned char *)0x57000088) //BCD year
N#endif  //RTC
N
N
N// ADC
N#define rADCCON    (*(volatile unsigned *)0x58000000) //ADC control
N#define rADCTSC    (*(volatile unsigned *)0x58000004) //ADC touch screen control
N#define rADCDLY    (*(volatile unsigned *)0x58000008) //ADC start or Interval Delay
N#define rADCDAT0   (*(volatile unsigned *)0x5800000c) //ADC conversion data 0
N#define rADCDAT1   (*(volatile unsigned *)0x58000010) //ADC conversion data 1                   
N                        
N// SPI          
N#define rSPCON0    (*(volatile unsigned *)0x59000000) //SPI0 control
N#define rSPSTA0    (*(volatile unsigned *)0x59000004) //SPI0 status
N#define rSPPIN0    (*(volatile unsigned *)0x59000008) //SPI0 pin control
N#define rSPPRE0    (*(volatile unsigned *)0x5900000c) //SPI0 baud rate prescaler
N#define rSPTDAT0   (*(volatile unsigned *)0x59000010) //SPI0 Tx data
N#define rSPRDAT0   (*(volatile unsigned *)0x59000014) //SPI0 Rx data
N
N#define rSPCON1    (*(volatile unsigned *)0x59000020) //SPI1 control
N#define rSPSTA1    (*(volatile unsigned *)0x59000024) //SPI1 status
N#define rSPPIN1    (*(volatile unsigned *)0x59000028) //SPI1 pin control
N#define rSPPRE1    (*(volatile unsigned *)0x5900002c) //SPI1 baud rate prescaler
N#define rSPTDAT1   (*(volatile unsigned *)0x59000030) //SPI1 Tx data
N#define rSPRDAT1   (*(volatile unsigned *)0x59000034) //SPI1 Rx data
N
N
N// SD Interface
N#define rSDICON     (*(volatile unsigned *)0x5a000000) //SDI control
N#define rSDIPRE     (*(volatile unsigned *)0x5a000004) //SDI baud rate prescaler
N#define rSDICARG    (*(volatile unsigned *)0x5a000008) //SDI command argument
N#define rSDICCON    (*(volatile unsigned *)0x5a00000c) //SDI command control
N#define rSDICSTA    (*(volatile unsigned *)0x5a000010) //SDI command status
N#define rSDIRSP0    (*(volatile unsigned *)0x5a000014) //SDI response 0
N#define rSDIRSP1    (*(volatile unsigned *)0x5a000018) //SDI response 1
N#define rSDIRSP2    (*(volatile unsigned *)0x5a00001c) //SDI response 2
N#define rSDIRSP3    (*(volatile unsigned *)0x5a000020) //SDI response 3
N#define rSDIDTIMER  (*(volatile unsigned *)0x5a000024) //SDI data/busy timer
N#define rSDIBSIZE   (*(volatile unsigned *)0x5a000028) //SDI block size
N#define rSDIDCON    (*(volatile unsigned *)0x5a00002c) //SDI data control
N#define rSDIDCNT    (*(volatile unsigned *)0x5a000030) //SDI data remain counter
N#define rSDIDSTA    (*(volatile unsigned *)0x5a000034) //SDI data status
N#define rSDIFSTA    (*(volatile unsigned *)0x5a000038) //SDI FIFO status
N#define rSDIIMSK    (*(volatile unsigned *)0x5a000040) //SDI interrupt mask
N
N#ifdef __BIG_ENDIAN
S#define rSDIDAT    (*(volatile unsigned *)0x5a00003f) //SDI data
S#define SDIDAT     0x5a00003f
N#else  // Little Endian
N#define rSDIDAT    (*(volatile unsigned *)0x5a00003c) //SDI data
N#define SDIDAT     0x5a00003c
N#endif   //SD Interface
N             
N#define _ISR_STARTADDRESS 0x33ffff00
N// ISR
N#define pISR_RESET     (*(unsigned *)(_ISR_STARTADDRESS+0x0))
N#define pISR_UNDEF     (*(unsigned *)(_ISR_STARTADDRESS+0x4))
N#define pISR_SWI       (*(unsigned *)(_ISR_STARTADDRESS+0x8))
N#define pISR_PABORT    (*(unsigned *)(_ISR_STARTADDRESS+0xc))
N#define pISR_DABORT    (*(unsigned *)(_ISR_STARTADDRESS+0x10))
N#define pISR_RESERVED  (*(unsigned *)(_ISR_STARTADDRESS+0x14))
N#define pISR_IRQ       (*(unsigned *)(_ISR_STARTADDRESS+0x18))
N#define pISR_FIQ       (*(unsigned *)(_ISR_STARTADDRESS+0x1c))
N
N#define pISR_EINT0     (*(unsigned *)(_ISR_STARTADDRESS+0x20))
N#define pISR_EINT1     (*(unsigned *)(_ISR_STARTADDRESS+0x24))
N#define pISR_EINT2     (*(unsigned *)(_ISR_STARTADDRESS+0x28))
N#define pISR_EINT3     (*(unsigned *)(_ISR_STARTADDRESS+0x2c))
N#define pISR_EINT4_7   (*(unsigned *)(_ISR_STARTADDRESS+0x30))
N#define pISR_EINT8_23  (*(unsigned *)(_ISR_STARTADDRESS+0x34))
N#define pISR_NOTUSED6  (*(unsigned *)(_ISR_STARTADDRESS+0x38))
N#define pISR_BAT_FLT   (*(unsigned *)(_ISR_STARTADDRESS+0x3c))
N#define pISR_TICK      (*(unsigned *)(_ISR_STARTADDRESS+0x40))
N#define pISR_WDT       (*(unsigned *)(_ISR_STARTADDRESS+0x44))
N#define pISR_TIMER0    (*(unsigned *)(_ISR_STARTADDRESS+0x48))
N#define pISR_TIMER1    (*(unsigned *)(_ISR_STARTADDRESS+0x4c))
N#define pISR_TIMER2    (*(unsigned *)(_ISR_STARTADDRESS+0x50))
N#define pISR_TIMER3    (*(unsigned *)(_ISR_STARTADDRESS+0x54))
N#define pISR_TIMER4    (*(unsigned *)(_ISR_STARTADDRESS+0x58))
N#define pISR_UART2     (*(unsigned *)(_ISR_STARTADDRESS+0x5c))
N#define pISR_LCD       (*(unsigned *)(_ISR_STARTADDRESS+0x60))
N#define pISR_DMA0      (*(unsigned *)(_ISR_STARTADDRESS+0x64))
N#define pISR_DMA1      (*(unsigned *)(_ISR_STARTADDRESS+0x68))
N#define pISR_DMA2      (*(unsigned *)(_ISR_STARTADDRESS+0x6c))
N#define pISR_DMA3      (*(unsigned *)(_ISR_STARTADDRESS+0x70))
N#define pISR_SDI       (*(unsigned *)(_ISR_STARTADDRESS+0x74))
N#define pISR_SPI0      (*(unsigned *)(_ISR_STARTADDRESS+0x78))
N#define pISR_UART1     (*(unsigned *)(_ISR_STARTADDRESS+0x7c))
N#define pISR_NOTUSED24 (*(unsigned *)(_ISR_STARTADDRESS+0x80))
N#define pISR_USBD      (*(unsigned *)(_ISR_STARTADDRESS+0x84))
N#define pISR_USBH      (*(unsigned *)(_ISR_STARTADDRESS+0x88))
N#define pISR_IIC       (*(unsigned *)(_ISR_STARTADDRESS+0x8c))
N#define pISR_UART0     (*(unsigned *)(_ISR_STARTADDRESS+0x90))
N#define pISR_SPI1      (*(unsigned *)(_ISR_STARTADDRESS+0x94))
N#define pISR_RTC       (*(unsigned *)(_ISR_STARTADDRESS+0x98))
N#define pISR_ADC       (*(unsigned *)(_ISR_STARTADDRESS+0x9c))
N
N
N// PENDING BIT
N#define BIT_EINT0      (0x1)
N#define BIT_EINT1      (0x1<<1)
N#define BIT_EINT2      (0x1<<2)
N#define BIT_EINT3      (0x1<<3)
N#define BIT_EINT4_7    (0x1<<4)
N#define BIT_EINT8_23   (0x1<<5)
N#define BIT_NOTUSED6   (0x1<<6)
N#define BIT_BAT_FLT    (0x1<<7)
N#define BIT_TICK       (0x1<<8)
N#define BIT_WDT        (0x1<<9)
N#define BIT_TIMER0     (0x1<<10)
N#define BIT_TIMER1     (0x1<<11)
N#define BIT_TIMER2     (0x1<<12)
N#define BIT_TIMER3     (0x1<<13)
N#define BIT_TIMER4     (0x1<<14)
N#define BIT_UART2      (0x1<<15)
N#define BIT_LCD        (0x1<<16)
N#define BIT_DMA0       (0x1<<17)
N#define BIT_DMA1       (0x1<<18)
N#define BIT_DMA2       (0x1<<19)
N#define BIT_DMA3       (0x1<<20)
N#define BIT_SDI        (0x1<<21)
N#define BIT_SPI0       (0x1<<22)
N#define BIT_UART1      (0x1<<23)
N#define BIT_NOTUSED24  (0x1<<24)
N#define BIT_USBD       (0x1<<25)
N#define BIT_USBH       (0x1<<26)
N#define BIT_IIC        (0x1<<27)
N#define BIT_UART0      (0x1<<28)
N#define BIT_SPI1       (0x1<<29)
N#define BIT_RTC        (0x1<<30)
N#define BIT_ADC        (0x80000000) //(0x1<<31)
N#define BIT_ALLMSK     (0xffffffff)
N
N#define BIT_SUB_ALLMSK (0x7ff)
N#define BIT_SUB_ADC    (0x1<<10)
N#define BIT_SUB_TC     (0x1<<9)
N#define BIT_SUB_ERR2   (0x1<<8)
N#define BIT_SUB_TXD2   (0x1<<7)
N#define BIT_SUB_RXD2   (0x1<<6)
N#define BIT_SUB_ERR1   (0x1<<5)
N#define BIT_SUB_TXD1   (0x1<<4)
N#define BIT_SUB_RXD1   (0x1<<3)
N#define BIT_SUB_ERR0   (0x1<<2)
N#define BIT_SUB_TXD0   (0x1<<1)
N#define BIT_SUB_RXD0   (0x1<<0)
N
N#define ClearPending(bit) {\
N                rSRCPND = bit;\
N                rINTPND = rINTPND;} // precent write wrong data
X#define ClearPending(bit) {                rSRCPND = bit;                rINTPND = rINTPND;} 
N
N//Wait until rINTPND is changed for the case that the ISR is very short.
N
N#ifdef __cplusplus
S}
N#endif
N#endif  //__2410ADDR_H___
N
L 16 "..\Common\Inc\2410lib.h" 2
N
N#ifndef __2410lib_h__
N#define __2410lib_h__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								constant define						 				    */
N/*------------------------------------------------------------------------------------------*/
N#define DOWNLOAD_ADDRESS _RAM_STARTADDRESS
N#define DEBUG_OUT uart_printf
N
N#define min(x1,x2) (((x1)<(x2))? (x1):(x2))
N#define max(x1,x2) (((x1)>(x2))? (x1):(x2))
N
N#define ONESEC0 (62500)								// 16us resolution, max 1.04 sec
N#define ONESEC1 (31250)								// 32us resolution, max 2.09 sec
N#define ONESEC2 (15625)								// 64us resolution, max 4.19 sec
N#define ONESEC3 (7812)								// 128us resolution, max 8.38 sec
N#define ONESEC4 (PCLK/128/(0xff+1))					// @60Mhz, 128*4us resolution, max 32.53 sec
N
N#define NULL 0
N#define LCD   0xDD									// LCD symbol
N#define UART0 0x0									// UART symbol
N#define UART1 0x1
N#define UART2 0xBB
N#define EnterPWDN(clkcon) ((void (*)(int))0x20)(clkcon)
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								fuction declare						 				    */
N/*------------------------------------------------------------------------------------------*/
Nvoid StartPointAfterPowerOffWakeUp(void);  
Nvoid sys_init(void);
Nvoid delay(int time);								// Watchdog Timer is used.
Nvoid port_init(void);
Nvoid uart_select(int ch);
Nvoid uart_txempty(int ch);
Nvoid uart_init(int nMainClk, int nBaud, int nChannel);
Nchar uart_getch(void);
Nchar uart_getkey(void);
Nint  uart_getintnum(void);
Nvoid uart_sendbyte(int data);
Nvoid uart_printf(char *fmt,...);
Nvoid uart_sendstring(char *pt);
Nvoid timer_start(int divider);						// Watchdog Timer is used.
Nint  timer_stop(void);								// Watchdog Timer is used.
N
Nvoid led_display(int data);
N
Nvoid change_value_MPLL(int m,int p,int s);
Nvoid change_clock_divider(int hdivn,int pdivn);
Nvoid ChangeUPllValue(int m,int p,int s);
Nvoid InitMMU(unsigned int *pTranslationTable);		
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								inline fuction define								    */
N/*------------------------------------------------------------------------------------------*/
N/*********************************************************************************************
N* name:		ARM_WriteTTB
N* func:		Write Translation table base  register
N* para:		TTB Address
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteTTB(unsigned int ttb)
N{
N 	__asm("MCR p15, 0, (ttb & 0xFFFFC000), c2, c0, 0");
N}
N
N/*********************************************************************************************
N* name:		ARM_WriteDomain
N* func:		Write domain access control
N* para:		Domain NO.
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteDomain(unsigned int domain)
N{
N 	__asm("MCR p15, 0, domain, c3, c0, 0");
N}
N
N/*********************************************************************************************
N* name:		ARM_ReadControl
N* func:		Read Control register
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline unsigned int ARM_ReadControl()
N{
N	register unsigned int ctl;
N 	__asm("MRC p15, 0, ctl, c1, c0, 0");
N 	return ctl;
N}
N
N/*********************************************************************************************
N* name:		ARM_WriteControl
N* func:		Write Control register
N* para:		Control Byte
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteControl(unsigned int ctl)
N{
N 	__asm("MCR p15, 0, ctl, c1, c0, 0");
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__2410lib_h__
N
L 13 "Source\color_lcd_test.c" 2
N#include "lcdlib.h"
L 1 ".\Include\lcdlib.h" 1
N/*********************************************************************************************
N* File£º	lcdlib.h
N* Author:	Embest	
N* Desc£º	header file of lcd lib 
N* History:	
N*			Y.J.Guo, Programming modify, April 12, 2005
N*********************************************************************************************/
N#ifndef __LCDLIB_H__
N#define __LCDLIB_H__
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								macro define						 				    */
N/*------------------------------------------------------------------------------------------*/
N#define BLACK 0x0
N#define WHITE 0xffff
N#define RED 0xf800
N#define GREEN 0x7e0
N#define BLUE 0x10
N#define ALLBLACK ((BLACK << 24) | (BLACK << 16) | (BLACK << 8) | BLACK)
N#define ALLWHITE ((WHITE << 24)  | (WHITE << 16)  | (WHITE << 8)  | WHITE)
N#define LIGHTGRAY    0xa0
N#define DARKGRAY     0x50
N#define TRANSPARENCY 0xff
N
N
N#define MVAL		(13)
N#define MVAL_USED 	(0)
N#define M5D(n) ((n) & 0x1fffff)                                 // To get lower 21bits
N#define GUISWAP(a, b){a^=b; b^=a; a^=b;}
N
N//STN LCD Panel(320*240)
N#define MODE_STN_1BIT 	(0x1001)
N#define MODE_STN_2BIT  	(0x1002)
N#define MODE_STN_4BIT  	(0x1004)
N//Color STN LCD Panel(320*240)
N#define MODE_CSTN_8BIT   (0x2001)
N#define MODE_CSTN_12BIT (0x2002)
N//TFT LCD Panel(240*320)
N#define MODE_TFT_1BIT_240320     (0x4101)
N#define MODE_TFT_8BIT_240320 	 (0x4102)
N#define MODE_TFT_16BIT_240320    (0x4104)
N//TFT LCD Panel(640*480)
N#define MODE_TFT_1BIT_640480     (0x4201)
N#define MODE_TFT_8BIT_640480     (0x4202)
N#define MODE_TFT_16BIT_640480    (0x4204)
N#define MODE_TFT_16BIT_800480    (0x4208)
N#define MODE_TFT_24BIT_640480    (0x42016)
N//TFT LCD Panel(800*600)
N#define MODE_TFT_1BIT_800600     (0x4401)
N#define MODE_TFT_8BIT_800600     (0x4402)
N#define MODE_TFT_16BIT_800600    (0x4404)
N
N//STN
N#define LCD_XSIZE_STN 	(320)
N#define LCD_YSIZE_STN 	(240)
N//Color STN
N#define LCD_XSIZE_CSTN 	(320)
N#define LCD_YSIZE_CSTN 	(240)
N//TFT 240320
N#define LCD_XSIZE_TFT_240320 	(240)	
N#define LCD_YSIZE_TFT_240320 	(320)
N//TFT 640480
N#define LCD_XSIZE_TFT_640480 	(640)	
N#define LCD_YSIZE_TFT_640480 	(480)
N//TFT 800480
N#define LCD_XSIZE_TFT_800480 	(800)	
N#define LCD_YSIZE_TFT_800480 	(480)
N//TFT 800600
N#define LCD_XSIZE_TFT_800600 	(800)	
N#define LCD_YSIZE_TFT_800600 	(600)
N//STN
N#define SCR_XSIZE_STN 	(LCD_XSIZE_STN*2)                       //for virtual screen  
N#define SCR_YSIZE_STN 	(LCD_YSIZE_STN*2)
N//Color STN
N#define SCR_XSIZE_CSTN 	(LCD_XSIZE_CSTN*2)        				//for virtual screen  
N#define SCR_YSIZE_CSTN 	(LCD_YSIZE_CSTN*2)
N//TFT 240320
N#define SCR_XSIZE_TFT_240320 	(LCD_XSIZE_TFT_240320*2)
N#define SCR_YSIZE_TFT_240320 	(LCD_YSIZE_TFT_240320*2)
N//TFT 640480
N#define SCR_XSIZE_TFT_640480 	(LCD_XSIZE_TFT_640480*2)
N#define SCR_YSIZE_TFT_640480 	(LCD_YSIZE_TFT_640480*2)
N//TFT 800480
N#define SCR_XSIZE_TFT_800480 	(LCD_XSIZE_TFT_800480*2)
N#define SCR_YSIZE_TFT_800480 	(LCD_YSIZE_TFT_800480*2)
N//TFT 800600
N#define SCR_XSIZE_TFT_800600 	(LCD_XSIZE_TFT_800600*2)
N#define SCR_YSIZE_TFT_800600 	(LCD_YSIZE_TFT_800600*2)
N
N//STN
N#define HOZVAL_STN		(LCD_XSIZE_STN/4-1)	                    // Valid VD data line number is 4.
N#define LINEVAL_STN		(LCD_YSIZE_STN-1)
N//Color STN
N#define HOZVAL_CSTN		(LCD_XSIZE_CSTN*3/8-1)	                // Valid VD data line number is 8.
N#define LINEVAL_CSTN		(LCD_YSIZE_CSTN-1)
N//TFT240320
N#define HOZVAL_TFT_240320	(LCD_XSIZE_TFT_240320-1)
N#define LINEVAL_TFT_240320	(LCD_YSIZE_TFT_240320-1)
N//TFT640480
N#define HOZVAL_TFT_640480	(LCD_XSIZE_TFT_640480-1)
N#define LINEVAL_TFT_640480	(LCD_YSIZE_TFT_640480-1)
N//TFT800480
N#define HOZVAL_TFT_800480	(LCD_XSIZE_TFT_800480-1)
N#define LINEVAL_TFT_800480	(LCD_YSIZE_TFT_800480-1)
N//TFT800600
N#define HOZVAL_TFT_800600	(LCD_XSIZE_TFT_800600-1)
N#define LINEVAL_TFT_800600	(LCD_YSIZE_TFT_800600-1)
N
N//STN
N#define WLH_STN	    		(0)
N#define WDLY_STN		(0)
N#define LINEBLANK_MONO		(1 &0xff)                           // MONO timing parameter for CPT CLS-040S-C3M(CHUNGHWA)
N#define LINEBLANK_GRAY		(13 &0xff)                          // GRAY timing parameter for CPT CLS-040S-C3M(CHUNGHWA)
N//CSTN timing parameter for LCBHBT161M(NANYA)
N#define WLH_CSTN	        (0)
N#define WDLY_CSTN		(0)
N#define LINEBLANK_CSTN		(16 &0xff)
N//Timing parameter for LTS350Q1(SAMSUNG) 
N#define VBPD_240320		((2-1)&0xff)
N#define VFPD_240320		((3-1)&0xff)
N#define VSPW_240320		((2-1) &0x3f)
N#define HBPD_240320		((7-1)&0x7f)
N#define HFPD_240320		((3-1)&0xff)
N#define HSPW_240320		((4-1)&0xff)
N//Timing parameter for V16C6448AB(PRIME VIEW) 
N#define VBPD_640480		((33-1)&0xff)
N#define VFPD_640480		((10-1)&0xff)
N#define VSPW_640480		((2-1) &0x3f)
N#define HBPD_640480		((48-1)&0x7f)
N#define HFPD_640480		((16-1)&0xff)
N#define HSPW_640480		((96-1)&0xff)
N
N#define VBPD_800480		((15)&0xff)//
N#define VFPD_800480		((15)&0xff)//
N#define VSPW_800480		((30) &0x3f)//
N#define HBPD_800480		((30)&0x7f)//
N#define HFPD_800480		((70)&0xff)//
N#define HSPW_800480		((100)&0xff)//
N
N//Timing parameter for LP104S5-B2AP(LGPHILIPS) 
N#define VBPD_800600        	((2-1)&0xff)
N#define VFPD_800600		((3-1)&0xff)
N#define VSPW_800600		((1-1) &0x3f)
N#define HBPD_800600		((30-1)&0x7f)
N#define HFPD_800600		((30-1)&0xff)
N#define HSPW_800600		((12-1)&0xff)
N
N
N#define CLKVAL_STN_MONO		(20) 	
N    // 64hz @50Mhz,WLH=16hclk,WDLY=16hclk,LINEBLANK=1*8hclk,VD=4 
N#define CLKVAL_STN_GRAY		(10) 	
N    // 120hz @50Mhz,WLH=16hclk,WDLY=16hclk,LINEBLANK=13*8hclk,VD=4 
N#define CLKVAL_CSTN		(6) 	
N    // 130hz @50Mhz,WLH=16hclk,WDLY=16hclk,LINEBLANK=16*8hclk,VD=8  
N#define CLKVAL_TFT_240320	(4) 	
N    // 60hz @50Mhz
N    //VSYNC,HSYNC should be inverted
N    //HBPD=6VCLK,HFPD=2VCLK,HSPW=3VCLK
N    //VBPD=1HSYNC,VFPD=2HSYNC,VSPW=1HSYNC
N#define CLKVAL_TFT_640480 	(1)
N    //53.5hz @90Mhz
N    //VSYNC,HSYNC should be inverted
N    //HBPD=47VCLK,HFPD=15VCLK,HSPW=95VCLK
N    //VBPD=32HSYNC,VFPD=9HSYNC,VSPW=1HSYNC
N#define CLKVAL_TFT_800480 	(0)
N#define CLKVAL_TFT_800600 	(0)
N    //85hz @90Mhz
N    //71hz @76Mhz
N    //VSYNC,HSYNC should be inverted
N    //HBPD=29VCLK,HFPD=29VCLK,HSPW=11VCLK
N    //VBPD=1HSYNC,VFPD=2HSYNC,VSPW=0HSYNC
N#define LCDFRAMEBUFFER 0x31000000 //_NONCACHE_STARTADDRESS 
N    // 1. The LCD frame buffer should be write-through or non-cachable.
N    // 2. The total frame memory should be inside 4MB.
N    // 3. To meet above 2 conditions, the frame buffer should be 
N    // inside the following regions.
N    // 0x31000000~0x313ffffff,
N    // 0x31400000~0x317ffffff,
N    // 0x31800000~0x31bffffff,
N    //        .....    
N    // 0x33800000~0x33bffffff                
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								external variables					 				    */
N/*------------------------------------------------------------------------------------------*/
N//Mono
Nextern UINT32T (*frameBuffer1Bit)[SCR_XSIZE_STN/32];
Xextern unsigned int (*frameBuffer1Bit)[((320)*2)/32];
N//Gray
Nextern UINT32T (*frameBuffer2Bit)[SCR_XSIZE_STN/16];
Xextern unsigned int (*frameBuffer2Bit)[((320)*2)/16];
Nextern UINT32T (*frameBuffer4Bit)[SCR_XSIZE_STN/8];
Xextern unsigned int (*frameBuffer4Bit)[((320)*2)/8];
N//Color STN
Nextern UINT32T (*frameBuffer8Bit)[SCR_XSIZE_CSTN/4];
Xextern unsigned int (*frameBuffer8Bit)[((320)*2)/4];
Nextern UINT32T (*frameBuffer12Bit)[SCR_XSIZE_CSTN*3/8];             // The least common multiple (between 12 and 32) is 96
Xextern unsigned int (*frameBuffer12Bit)[((320)*2)*3/8];             
N//TFT 240320
Nextern UINT32T (*frameBuffer8BitTft240320)[SCR_XSIZE_TFT_240320/4];
Xextern unsigned int (*frameBuffer8BitTft240320)[((240)*2)/4];
Nextern UINT32T (*frameBuffer16BitTft240320)[SCR_XSIZE_TFT_240320/2];
Xextern unsigned int (*frameBuffer16BitTft240320)[((240)*2)/2];
N//TFT 640480
Nextern UINT32T (*frameBuffer1BitTft640480)[SCR_XSIZE_TFT_640480/32];
Xextern unsigned int (*frameBuffer1BitTft640480)[((640)*2)/32];
Nextern UINT32T (*frameBuffer8BitTft640480)[SCR_XSIZE_TFT_640480/4];
Xextern unsigned int (*frameBuffer8BitTft640480)[((640)*2)/4];
Nextern UINT32T (*frameBuffer16BitTft640480)[SCR_XSIZE_TFT_640480/2];
Xextern unsigned int (*frameBuffer16BitTft640480)[((640)*2)/2];
Nextern UINT32T (*frameBuffer16BitTft800480)[SCR_XSIZE_TFT_800480/2];
Xextern unsigned int (*frameBuffer16BitTft800480)[((800)*2)/2];
Nextern UINT32T (*frameBuffer24BitTft640480)[SCR_XSIZE_TFT_640480];  // Unpacked 24bit 
Xextern unsigned int (*frameBuffer24BitTft640480)[((640)*2)];  
N//TFT 800600
Nextern UINT32T (*frameBuffer1BitTft800600)[SCR_XSIZE_TFT_800600/32];
Xextern unsigned int (*frameBuffer1BitTft800600)[((800)*2)/32];
Nextern UINT32T (*frameBuffer8BitTft800600)[SCR_XSIZE_TFT_800600/4];
Xextern unsigned int (*frameBuffer8BitTft800600)[((800)*2)/4];
Nextern UINT32T (*frameBuffer16BitTft800600)[SCR_XSIZE_TFT_800600/2];
Xextern unsigned int (*frameBuffer16BitTft800600)[((800)*2)/2];
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								function declare                                        */
N/*------------------------------------------------------------------------------------------*/
Nvoid Lcd_Init(int type);
Nvoid MoveViewPort(int);
Nvoid Lcd_CstnOnOff(int onoff);
Nvoid Lcd_EnvidOnOff(int onoff);
Nvoid Lcd_PowerEnable(int invpwren,int pwren);
Nvoid Lcd_MoveViewPort(int vx,int vy,int type);
Nvoid Lcd_Lpc3600Enable(void);
N
N
N#endif                                                          //__LCDLIB_H__
L 14 "Source\color_lcd_test.c" 2
N#include "glib.h"
L 1 ".\Include\glib.h" 1
N/*********************************************************************************************
N* File£º	glib.h
N* Author:	Embest	
N* Desc£º	header file of general lib
N* History:	
N*			Y.J.Guo, Programming modify, April 12, 2005
N*********************************************************************************************/
N#ifndef __GLIB_H__
N#define __GLIB_H__
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								functions declare						                */
N/*------------------------------------------------------------------------------------------*/
Nvoid Glib_Init(int type);                                       
N
Nvoid Glib_Line(int x1,int y1,int x2,int y2,int color);          
Nvoid Glib_Rectangle(int x1,int y1,int x2,int y2,int color);
Nvoid Glib_FilledRectangle(int x1,int y1,int x2,int y2,int color);
Nvoid Glib_ClearScr(UINT32T c,int type);
Xvoid Glib_ClearScr(unsigned int c,int type);
N
Nvoid _PutStn1Bit(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutStn1Bit(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutStn2Bit(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutStn2Bit(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutStn4Bit(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutStn4Bit(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutCstn8Bit(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutCstn8Bit(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutCstn12Bit(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutCstn12Bit(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft8Bit_240320(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft8Bit_240320(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft16Bit_240320(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft16Bit_240320(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft1Bit_640480(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft1Bit_640480(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft8Bit_640480(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft8Bit_640480(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft16Bit_640480(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft16Bit_640480(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft16Bit_800480(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft16Bit_800480(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft24Bit_640480(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft24Bit_640480(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft1Bit_800600(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft1Bit_800600(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft8Bit_800600(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft8Bit_800600(unsigned int x,unsigned int y,unsigned int c);
Nvoid _PutTft16Bit_800600(UINT32T x,UINT32T y,UINT32T c);
Xvoid _PutTft16Bit_800600(unsigned int x,unsigned int y,unsigned int c);
N
N//add by Y.J.GUO April 13,2005
Nvoid BitmapViewStn1Bit(UINT8T *pBuffer);
Xvoid BitmapViewStn1Bit(unsigned char *pBuffer);
Nvoid BitmapViewStn2Bit(UINT8T *pBuffer);
Xvoid BitmapViewStn2Bit(unsigned char *pBuffer);
Nvoid BitmapViewStn4Bit(UINT8T *pBuffer);
Xvoid BitmapViewStn4Bit(unsigned char *pBuffer);
Nvoid BitmapViewCstn8Bit(UINT8T *pBuffer);
Xvoid BitmapViewCstn8Bit(unsigned char *pBuffer);
Nvoid BitmapViewCstn12Bit(UINT8T *pBuffer);
Xvoid BitmapViewCstn12Bit(unsigned char *pBuffer);
Nvoid BitmapViewTft8Bit_240320(UINT8T *pBuffer);
Xvoid BitmapViewTft8Bit_240320(unsigned char *pBuffer);
Nvoid BitmapViewTft16Bit_240320(UINT8T *pBuffer);
Xvoid BitmapViewTft16Bit_240320(unsigned char *pBuffer);
Nvoid BitmapViewTft1Bit_640480(UINT8T *pBuffer);
Xvoid BitmapViewTft1Bit_640480(unsigned char *pBuffer);
Nvoid BitmapViewTft8Bit_640480(UINT8T *pBuffer);
Xvoid BitmapViewTft8Bit_640480(unsigned char *pBuffer);
Nvoid BitmapViewTft16Bit_640480(UINT8T *pBuffer);
Xvoid BitmapViewTft16Bit_640480(unsigned char *pBuffer);
Nvoid BitmapViewTft16Bit_800480(UINT8T *pBuffer);
Xvoid BitmapViewTft16Bit_800480(unsigned char *pBuffer);
Nvoid BitmapViewTft24Bit_640480(UINT8T *pBuffer);
Xvoid BitmapViewTft24Bit_640480(unsigned char *pBuffer);
Nvoid BitmapViewTft1Bit_800600(UINT8T *pBuffer);
Xvoid BitmapViewTft1Bit_800600(unsigned char *pBuffer);
Nvoid BitmapViewTft8Bit_800600(UINT8T *pBuffer);
Xvoid BitmapViewTft8Bit_800600(unsigned char *pBuffer);
Nvoid BitmapViewTft16Bit_800600(UINT8T *pBuffer);
Xvoid BitmapViewTft16Bit_800600(unsigned char *pBuffer);
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								extern functions declare                                */
N/*------------------------------------------------------------------------------------------*/
Nextern void (*PutPixel)(UINT32T,UINT32T,UINT32T);
Xextern void (*PutPixel)(unsigned int,unsigned int,unsigned int);
Nextern void (*BitmapView)(UINT8T *pBuffer);
Xextern void (*BitmapView)(unsigned char *pBuffer);
N
N#endif                                                          //__GLIB_H__
L 15 "Source\color_lcd_test.c" 2
N#include "lcd.h"
L 1 ".\Include\lcd.h" 1
N/*********************************************************************************************
N* File£º	lcd.h
N* Author:	Embest	
N* Desc£º	header file of lcd 
N* History:	
N*			Y.J.Guo, Programming modify, April 12, 2005
N*********************************************************************************************/
N#ifndef __LCD_H__
N#define __LCD_H__
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								function declare                                        */
N/*------------------------------------------------------------------------------------------*/
Nvoid Test_Lcd_Stn_1Bit(void);
Nvoid Test_Lcd_Stn_2Bit(void);
Nvoid Test_Lcd_Stn_4Bit(void);
Nvoid Test_Lcd_Cstn_8Bit(void);
Nvoid Test_Lcd_Cstn_12Bit(void);
Nvoid Test_Lcd_Cstn_8Bit_On(void);
Nvoid Test_Lcd_Tft_8Bit_240320(void);
Nvoid Test_Lcd_Tft_8Bit_240320_On(void);
Nvoid Test_Lcd_Tft_16Bit_240320(void);
Nvoid Test_Lcd_Tft_1Bit_640480(void);
Nvoid Test_Lcd_Tft_8Bit_640480(void);
Nvoid Test_Lcd_Tft_16Bit_640480(void);
Nvoid Test_Lcd_Tft_24Bit_640480(void);
Nvoid Test_Lcd_Tft_8Bit_640480_Palette(void);
Nvoid Test_Lcd_Tft_8Bit_640480_Bswp(void);
Nvoid Test_Lcd_Tft_16Bit_640480_Hwswp(void);
Nvoid Test_Lcd_Tft_16Bit_640480_Bmp(void);
Nvoid Test_Lcd_Tft_1Bit_800600(void);
Nvoid Test_Lcd_Tft_8Bit_800600(void);
Nvoid Test_Lcd_Tft_16Bit_800600(void);
N
N#endif                                                          //__LCD_H__
L 16 "Source\color_lcd_test.c" 2
N#include <math.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 178085 $ Codemist 0.03
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5030024
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199409L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_SOFTFP __declspec(__nothrow) __softfp
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __pure
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#ifdef __BIG_ENDIAN
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* ndef __BIG_ENDIAN */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* ndef __BIG_ENDIAN */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern __softfp unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Nextern __softfp unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#define HUGE_VAL ((double)__INFINITY__)
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __pure double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __pure double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __pure double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __pure double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __pure double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __pure double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __pure float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __pure double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __pure float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __pure float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __pure float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __pure float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
Sextern _ARMABI __int64 llrint(double /*x*/);
Sextern _ARMABI __int64 llrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x)     { return llrint((double)__x); }
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
Sextern _ARMABI __int64 llround(double /*x*/);
Sextern _ARMABI __int64 llroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x)     { return llround((double)__x); }
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __int64 llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __int64 llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __int64 llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __int64 llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S      using ::std::fmal;
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S      using ::std::lrintl;
S      using ::std::llrint;
S      using ::std::llrintf;
S      using ::std::llrintl;
S      using ::std::lround;
S      using ::std::lroundf;
S      using ::std::lroundl;
S      using ::std::llround;
S      using ::std::llroundf;
S      using ::std::llroundl;
S      using ::std::nan;
S      using ::std::nanf;
S      using ::std::nanl;
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S      using ::std::remquol;
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#endif /* __math_h */
N
N/* end of math.h */
N
L 17 "Source\color_lcd_test.c" 2
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								constant define							 			    */
N/*------------------------------------------------------------------------------------------*/
N#define LCD_BUF_SIZE		(SCR_XSIZE_TFT_640480*SCR_YSIZE_TFT_640480/2)
N#define LCD_ACTIVE_BUFFER	(0x33800000)
N#define LCD_VIRTUAL_BUFFER  (0x33800000 + LCD_BUF_SIZE)
N#define LCD_D_OFF 			rGPCDAT &= ~(1 << 4); 
N#define LCD_D_ON 			rGPCDAT |= (1 << 4); 
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								extern variables						 			    */
N/*------------------------------------------------------------------------------------------*/
N#ifdef BOARDTEST_EXH
S#undef BOARDTEST
N#endif	
N
N#ifndef BOARDTEST	
Nextern const UINT8T g_ucBitmap[][76800];
Xextern const unsigned char g_ucBitmap[][76800];
Nextern UINT8T g_ucAscii8x16[];
Xextern unsigned char g_ucAscii8x16[];
Nextern UINT8T g_auc_Ascii6x8[];
Xextern unsigned char g_auc_Ascii6x8[];
Nextern UINT8T g_auc_hzk24[];
Xextern unsigned char g_auc_hzk24[];
N#endif
N 
N/*------------------------------------------------------------------------------------------*/
N/*	 								function declare                                        */
N/*------------------------------------------------------------------------------------------*/
Nvoid lcd_clr(void);
Nextern void Lcd_port_init(void);
Nextern void Lcd_Port_Return(void);
N
N/*********************************************************************************************
N* name:		lcd_init_app
N* func:		lcd application initialization code 
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid lcd_init_app()
N{
N    Lcd_port_init();
N    Lcd_Init(MODE_TFT_16BIT_800480);
X    Lcd_Init((0x4208));
N    Glib_Init(MODE_TFT_16BIT_800480);
X    Glib_Init((0x4208));
N    Glib_ClearScr(0, MODE_TFT_16BIT_800480);
X    Glib_ClearScr(0, (0x4208));
N    Lcd_PowerEnable(0, 1);
N    Lcd_EnvidOnOff(1);	  
N    uart_printf(" [TFT 64K COLOR(16bit/1pixel) LCD TEST]\n");
N
N}
N
N/*********************************************************************************************
N* name:		lcd_init_app_end
N* func:		end lcd application initialization
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid lcd_init_app_end()
N{
N    Lcd_EnvidOnOff(0);
N    Lcd_Port_Return();
N}
N
N
N
N/*********************************************************************************************
N* name:		Lcd_Draw_Line()
N* func:		Draw line with appointed color
N* para:		usX0,usY0 -- line's start point coordinate
N*			usX1,usY1 -- line's end point coordinate
N*			ucColor -- appointed color value
N*			usWidth -- line's width
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid Lcd_Draw_Line(INT16T usX0, INT16T usY0, INT16T usX1, INT16T usY1, UINT16T ucColor, UINT16T usWidth)
Xvoid Lcd_Draw_Line(short int usX0, short int usY0, short int usX1, short int usY1, unsigned short ucColor, unsigned short usWidth)
N{
N	INT16T usDx;
X	short int usDx;
N	INT16T usDy;
X	short int usDy;
N	INT16T y_sign;
X	short int y_sign;
N	INT16T x_sign;
X	short int x_sign;
N	INT16T decision;
X	short int decision;
N	INT16T wCurx, wCury, wNextx, wNexty, wpy, wpx;
X	short int wCurx, wCury, wNextx, wNexty, wpy, wpx;
N
W "Source\color_lcd_test.c" 104 9 function "abs" declared implicitly
N	usDx = abs(usX0 - usX1);
N	usDy = abs(usY0 - usY1);
N	if( ((usDx >= usDy && (usX0 > usX1)) ||
N        ((usDy > usDx) && (usY0 > usY1))) )
N    {
N        GUISWAP(usX1, usX0);
X        {usX1^=usX0; usX0^=usX1; usX1^=usX0;};
N        GUISWAP(usY1, usY0);
X        {usY1^=usY0; usY0^=usY1; usY1^=usY0;};
N    }
N    y_sign = (usY1 - usY0) / usDy;
N    x_sign = (usX1 - usX0) / usDx;
N
N    if( usDx >= usDy )
N    {
N        for( wCurx = usX0, wCury = usY0, wNextx = usX1,
N             wNexty = usY1, decision = (usDx >> 1);
N             wCurx <= wNextx; wCurx++, wNextx--, decision += usDy )
N        {
N            if( decision >= usDx )
N            {
N                decision -= usDx;
N                wCury += y_sign;
N                wNexty -= y_sign;
N            }
N            for( wpy = wCury - usWidth / 2;
N                 wpy <= wCury + usWidth / 2; wpy++ )
N            {
N                PutPixel(wCurx, wpy, ucColor);
N            }
N
N            for( wpy = wNexty - usWidth / 2;
N                 wpy <= wNexty + usWidth / 2; wpy++ )
N            {
N                PutPixel(wNextx, wpy, ucColor);
N            }
N        }
N    }
N    else
N    {
N        for( wCurx = usX0, wCury = usY0, wNextx = usX1,
N             wNexty = usY1, decision = (usDy >> 1);
N             wCury <= wNexty; wCury++, wNexty--, decision += usDx )
N        {
N            if( decision >= usDy )
N            {
N                decision -= usDy;
N                wCurx += x_sign;
N                wNextx -= x_sign;
N            }
N            for( wpx = wCurx - usWidth / 2;
N                 wpx <= wCurx + usWidth / 2; wpx++ )
N            {
N                PutPixel(wpx, wCury, ucColor);
N            }
N
N            for( wpx = wNextx - usWidth / 2;
N                 wpx <= wNextx + usWidth / 2; wpx++ )
N            {
N                PutPixel(wpx, wNexty, ucColor);
N            }
N        }
N    }
N}
N
N/*********************************************************************************************
N* name:		color_lcd_test()
N* func:		LCD test function
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid color_lcd_test(void)
N{
N	int i=290;
N	int j = 150;
N	float xx = 0;
N	int lastX = 50;
N	int lastY = 230;
N	int time =300;
N	uart_printf("\n LCD display Test Example (please look at LCD screen)\n");
N
N	lcd_init_app();
N	BitmapViewTft16Bit_800480((UINT8T *)(g_ucBitmap));
X	BitmapViewTft16Bit_800480((unsigned char *)(g_ucBitmap));
N
N	/*
N	Lcd_Draw_Line(5,5,795,475,BLACK,1);
N	Lcd_Draw_Line(10,10,790,470,RED,1);
N	Lcd_Draw_Line(15,15,785,465,BLUE,1);
N	Lcd_Draw_Line(20,20,780,460,GREEN,1);*/
N
N	Lcd_Draw_Line(0, 230, 900, 230, RED, 5);
X	Lcd_Draw_Line(0, 230, 900, 230, 0xf800, 5);
N	Lcd_Draw_Line(50, 0, 50, 460, RED, 5);
X	Lcd_Draw_Line(50, 0, 50, 460, 0xf800, 5);
N	//Lcd_Draw_Line(0, 230, 100,100, RED, 5);
N	while(j--)
N	{
N		Lcd_Draw_Line(lastX, lastY, lastX+5,230-(sin(xx+0.1)*50), RED, 2);
X		Lcd_Draw_Line(lastX, lastY, lastX+5,230-(sin(xx+0.1)*50), 0xf800, 2);
N		
N		lastX = lastX+5;
N		lastY = 230-(sin(xx+0.1)*50);
N		xx+=0.1;
N	}
N
N	while(1);
N 
N
W "Source\color_lcd_test.c" 177 6 variable "i" was declared but never referenced
W "Source\color_lcd_test.c" 182 6 variable "time" was declared but never referenced
N}
